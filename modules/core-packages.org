#+TITLE: Core Packages Module
#+AUTHOR: Chris
#+DESCRIPTION: Essential packages for development
#+STARTUP: overview

* Core Development Packages

** Essential Packages
#+BEGIN_SRC emacs-lisp
;; Projectile for project management
(unless (package-installed-p 'projectile)
  (package-install 'projectile))

(require 'projectile)
(projectile-mode +1)

;; Vertico ecosystem - modern completion
(unless (package-installed-p 'vertico)
  (package-install 'vertico))

(unless (package-installed-p 'consult)
  (package-install 'consult))

(unless (package-installed-p 'marginalia)
  (package-install 'marginalia))

(unless (package-installed-p 'orderless)
  (package-install 'orderless))

;; Load and configure
(require 'vertico)
(require 'consult)
(require 'marginalia)
(require 'orderless)

(vertico-mode 1)
(marginalia-mode 1)

(setq completion-styles '(orderless basic)
      completion-category-defaults nil
      completion-category-overrides '((file (styles partial-completion))))

;; Enhanced keybindings - only if functions exist
(when (fboundp 'consult-M-x)
  (global-set-key (kbd "M-x") 'consult-M-x))

(when (fboundp 'consult-buffer)
  (global-set-key (kbd "C-x b") 'consult-buffer))

(when (fboundp 'consult-recent-file)
  (global-set-key (kbd "C-x C-r") 'consult-recent-file))

(when (fboundp 'consult-line)
  (global-set-key (kbd "C-s") 'consult-line))

;; Fallback keybindings if consult isn't available
(unless (fboundp 'consult-recent-file)
  (global-set-key (kbd "C-x C-r") 'recentf-open-files))

(unless (fboundp 'consult-buffer)
  (global-set-key (kbd "C-x b") 'switch-to-buffer))

;; Dark company completion menu
(with-eval-after-load 'company
  (set-face-background 'company-tooltip "#1e1e1e")
  (set-face-foreground 'company-tooltip "#d4d4d4")
  (set-face-background 'company-tooltip-selection "#264f78")
  (set-face-foreground 'company-tooltip-selection "#ffffff"))

;; Install and configure ripgrep package for proper interactive search
(unless (package-installed-p 'rg)
  (package-install 'rg))

(require 'rg)

;; Configure rg package
(setq rg-executable "rg")
(setq rg-group-result t)
(setq rg-hide-command t)
(setq rg-show-columns nil)
(setq rg-align-position-numbers t)
(setq rg-align-line-number-field-length 3)
(setq rg-align-column-number-field-length 3)

;; Project-aware ripgrep function using the rg package
(defun my-ripgrep-project (pattern)
  "Search in project using rg package - interactive results with jump capability."
  (interactive (list (read-string "Ripgrep project search: ")))
  (let ((project-root (or (and (fboundp 'projectile-project-root)
                               (projectile-project-root))
                          ;; Fallback: look for common project markers
                          (locate-dominating-file default-directory ".git")
                          (locate-dominating-file default-directory "go.mod")
                          (locate-dominating-file default-directory "CMakeLists.txt")
                          (locate-dominating-file default-directory "Cargo.toml")
                          (locate-dominating-file default-directory "package.json")
                          default-directory)))
    (let ((default-directory project-root))
      (rg pattern "*" project-root))
    ;; Focus the rg results window
    (run-with-timer 0.1 nil
                    (lambda ()
                      (let ((rg-window (get-buffer-window "*rg*")))
                        (when rg-window
                          (select-window rg-window)
                          (goto-char (point-min))
                          ;; Move to first result
                          (when (re-search-forward "^[0-9]+:" nil t)
                            (beginning-of-line))))))))

;; Current directory ripgrep function
(defun my-ripgrep-current-dir (pattern)
  "Search in current directory using rg package - interactive results."
  (interactive (list (read-string "Ripgrep current dir search: ")))
  (rg pattern "*" default-directory)
  ;; Focus the rg results window
  (run-with-timer 0.1 nil
                  (lambda ()
                    (let ((rg-window (get-buffer-window "*rg*")))
                      (when rg-window
                        (select-window rg-window)
                        (goto-char (point-min))
                        ;; Move to first result
                        (when (re-search-forward "^[0-9]+:" nil t)
                          (beginning-of-line)))))))

;; Enhanced ripgrep with preview like xref
(defun my-ripgrep-with-preview (pattern)
  "Search with ripgrep and show results with interactive preview."
  (interactive (list (read-string "Ripgrep search: ")))
  (let ((project-root (or (and (fboundp 'projectile-project-root)
                               (projectile-project-root))
                          (locate-dominating-file default-directory ".git")
                          default-directory)))
    (rg-search-with-preview pattern "." project-root)))

(defun rg-search-with-preview (pattern files-pattern directory)
  "Run ripgrep and show results with preview."
  (let* ((buf (get-buffer-create "*rg-preview*"))
         (original-window (selected-window))
         (original-buffer (current-buffer))
         (results '())
         (default-directory directory))

    ;; Run ripgrep and parse results
    (with-temp-buffer
      (let ((exit-code (call-process "rg" nil t nil
                                     "--line-number"
                                     "--column"
                                     "--no-heading"
                                     "--max-depth" "10"
                                     "--glob" "!test_area/src/*"
                                     "--glob" "!build/*"
                                     "--glob" "!.git/*"
                                     pattern
                                     ".")))
        (if (not (= exit-code 0))
            (message "Ripgrep failed with exit code %d. Output: %s" exit-code (buffer-string))
          (message "Ripgrep found results, parsing...")))

      (goto-char (point-min))
      (while (not (eobp))
        (when (looking-at "\\([^:]+\\):\\([0-9]+\\):\\([0-9]+\\):\\(.*\\)")
          (let ((file-path (match-string 1)))
            ;; Convert relative path to absolute path
            (unless (file-name-absolute-p file-path)
              (setq file-path (expand-file-name file-path directory)))
            (push (list file-path  ; absolute file path
                       (string-to-number (match-string 2))  ; line
                       (string-to-number (match-string 3))  ; column
                       (match-string 4)) ; content
                  results)))
        (forward-line 1)))

    (setq results (reverse results))
    (message "Found %d ripgrep results" (length results))

    (when results
      (with-current-buffer buf
        (setq buffer-read-only nil)
        (erase-buffer)
        (insert "Navigate with ↑/↓, jump with RET, quit with q\n")
        (insert "─────────────────────────────────────────────────\n\n")

        ;; Store data as buffer-local variables
        (setq-local rg-preview-list results)
        (setq-local rg-preview-index 0)
        (setq-local rg-preview-original-window original-window)
        (setq-local rg-preview-original-buffer original-buffer)
        (setq-local rg-preview-current-overlay nil)

        ;; Prevent auto-focus interference
        (setq-local auto-focus-disabled t)

        ;; Insert results
        (dolist (result results)
          (let ((file (nth 0 result))
                (line (nth 1 result))
                (content (nth 3 result)))
            (insert (format "%s:%d: %s\n"
                           (file-name-nondirectory file)
                           line
                           content))))

        (goto-char (point-min))
        (forward-line 3) ; Skip header
        (setq buffer-read-only t)

        ;; Define local keymap
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "<up>") 'rg-preview-up)
          (define-key map (kbd "<down>") 'rg-preview-down)
          (define-key map (kbd "p") 'rg-preview-up)
          (define-key map (kbd "n") 'rg-preview-down)
          (define-key map (kbd "<return>") 'rg-preview-jump)
          (define-key map (kbd "RET") 'rg-preview-jump)
          (define-key map (kbd "q") 'rg-preview-quit)
          (define-key map (kbd "C-g") 'rg-preview-quit)
          (define-key map (kbd "<escape>") 'rg-preview-quit)
          (use-local-map map)))

      ;; Display the buffer in bottom window
      (display-buffer buf '(display-buffer-at-bottom . ((window-height . 15))))
      (select-window (get-buffer-window buf))

      ;; Show initial preview in main window
      (rg-preview-update-display)

      ;; Clear any selection mode
      (deactivate-mark)
      (setq mark-active nil)
      (setq-local transient-mark-mode nil)
      (setq-local cua-mode nil))))

(defun rg-preview-up ()
  "Move to previous rg result."
  (interactive)
  (when (> rg-preview-index 0)
    (setq rg-preview-index (1- rg-preview-index))
    (rg-preview-update-display)))

(defun rg-preview-down ()
  "Move to next rg result."
  (interactive)
  (when (< rg-preview-index (1- (length rg-preview-list)))
    (setq rg-preview-index (1+ rg-preview-index))
    (rg-preview-update-display)))

(defun rg-preview-jump ()
  "Jump to selected rg result."
  (interactive)
  (let ((result (nth rg-preview-index rg-preview-list))
        (orig-win rg-preview-original-window)
        (current-win (selected-window))
        (current-buf (current-buffer))
        (current-overlay rg-preview-current-overlay))

    ;; Clean up highlight overlay
    (when (and current-overlay (overlay-buffer current-overlay))
      (delete-overlay current-overlay))

    ;; Kill the preview buffer
    (set-buffer-modified-p nil)
    (kill-buffer current-buf)

    ;; Close the preview window
    (when (> (length (window-list)) 1)
      (delete-window current-win))

    ;; Jump to the location in the main window
    (when (window-live-p orig-win)
      (select-window orig-win))
    (find-file (nth 0 result))
    (goto-char (point-min))
    (forward-line (1- (nth 1 result)))
    (move-to-column (1- (nth 2 result)))))

(defun rg-preview-quit ()
  "Quit rg preview."
  (interactive)
  (let ((orig-buf rg-preview-original-buffer)
        (orig-win rg-preview-original-window)
        (current-buf (current-buffer))
        (current-win (selected-window))
        (current-overlay rg-preview-current-overlay))

    ;; Clean up highlight overlay
    (when (and current-overlay (overlay-buffer current-overlay))
      (delete-overlay current-overlay))

    ;; Force kill the current buffer
    (set-buffer-modified-p nil)
    (kill-buffer current-buf)

    ;; Close the window if it's not the only one
    (when (> (length (window-list)) 1)
      (delete-window current-win))

    ;; Restore original state
    (when (window-live-p orig-win)
      (select-window orig-win))
    (when (buffer-live-p orig-buf)
      (switch-to-buffer orig-buf))))

(defun rg-preview-update-display ()
  "Update the display and preview."
  (let ((buf (current-buffer)))
    ;; Update selection highlighting
    (with-current-buffer buf
      (setq buffer-read-only nil)
      (goto-char (point-min))
      (forward-line 3) ; Skip header

      ;; Remove previous highlighting
      (remove-overlays (point) (point-max) 'face)

      ;; Add highlighting to current line
      (forward-line rg-preview-index)
      (let ((overlay (make-overlay (line-beginning-position) (line-end-position))))
        (overlay-put overlay 'face 'highlight))

      (setq buffer-read-only t))

    ;; Update preview in main window
    (when (< rg-preview-index (length rg-preview-list))
      (rg-preview-show-location-in-main (nth rg-preview-index rg-preview-list) rg-preview-original-window))))

(defun rg-preview-show-location-in-main (result original-window)
  "Show ripgrep result in the main window."
  (let* ((file (nth 0 result))
         (line (nth 1 result))
         (column (nth 2 result))
         (preview-buf (get-buffer "*rg-preview*")))

    (with-selected-window original-window

      ;; Clean up previous overlay first
      (when (and preview-buf
                 (buffer-local-value 'rg-preview-current-overlay preview-buf))
        (let ((old-overlay (buffer-local-value 'rg-preview-current-overlay preview-buf)))
          (when (and old-overlay (overlay-buffer old-overlay))
            (delete-overlay old-overlay))))

      (find-file file)
      (goto-char (point-min))
      (forward-line (1- line))
      (move-to-column (1- column))
      (recenter)

      ;; Create highlight overlay for the line in main window
      (let ((overlay (make-overlay (line-beginning-position) (line-end-position))))
        (overlay-put overlay 'face '(:background "#3a3a3a" :foreground "white"))

        ;; Store the overlay reference in the preview buffer for cleanup
        (when preview-buf
          (with-current-buffer preview-buf
            (setq-local rg-preview-current-overlay overlay)))))))

;; Ripgrep keybindings - now with preview
(global-set-key (kbd "C-c r") 'my-ripgrep-with-preview)     ; C-c r = ripgrep project with preview
(global-set-key (kbd "C-c R") 'my-ripgrep-current-dir)      ; C-c R = ripgrep current directory
(global-set-key (kbd "C-c g") 'rg-menu)                     ; C-c g = ripgrep menu for advanced options

;; Header/Implementation switcher - use ff-find-other-file (built-in)
;; This is more reliable than external packages
(global-set-key (kbd "C-x z") 'ff-find-other-file)
(message "Header/implementation switcher (ff-find-other-file) configured (C-x z)")

;; Debug: Show what's actually bound
(message "C-x C-r bound to: %s" (key-binding (kbd "C-x C-r")))
(message "C-x b bound to: %s" (key-binding (kbd "C-x b")))

;; Company for completions (must be before eglot)
(unless (package-installed-p 'company)
  (package-install 'company))

(require 'company)
(global-company-mode 1)
(setq company-idle-delay 0.1)
(setq company-minimum-prefix-length 1)

;; Eglot for LSP
(require 'eglot)
(add-to-list 'eglot-server-programs '(c-mode . ("clangd")))
(add-hook 'c-mode-hook 'eglot-ensure)
#+END_SRC

** Module Test
#+BEGIN_SRC emacs-lisp
(defun test-core-packages-module ()
  "Test core packages module functionality."
  (interactive)
  (let ((results '()))

    ;; Test package availability
    (dolist (pkg '(projectile vertico consult marginalia orderless))
      (if (featurep pkg)
          (push (format "%s: LOADED" pkg) results)
        (push (format "%s: NOT LOADED" pkg) results)))

    ;; Test key bindings
    (dolist (key '("M-x" "C-x b" "C-s"))
      (let ((binding (key-binding (kbd key))))
        (push (format "%s -> %s" key binding) results)))

    ;; Display results
    (with-current-buffer (get-buffer-create "*Core Packages Test*")
      (erase-buffer)
      (insert "=== Core Packages Module Test ===\n\n")
      (dolist (result (reverse results))
        (insert (format "%s\n" result)))
      (display-buffer (current-buffer)))

    (message "Core packages test completed")))
#+END_SRC