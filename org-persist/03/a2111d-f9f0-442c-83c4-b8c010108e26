;;   -*- mode: lisp-data; -*-
(((elisp org-element--headline-cache) . #s(avl-tree- [[[nil nil #2=(headline (:standard-properties [118 118 147 15134 15134 0 #1=(:title) nil element t nil 149 15132 1 nil nil nil #6=(org-data (:standard-properties [1 1 1 15134 15134 0 nil org-data nil t nil 3 15134 nil nil nil nil nil] :path "c:/Users/chris/AppData/Roaming/.emacs.d/modules/core-packages.org" :CATEGORY "core-packages"))] :pre-blank 1 :raw-value [org-element-deferred org-element--headline-raw-value (2 27) t] :title #3=[org-element-deferred org-element-property-2 (:raw-value) nil] :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :footnote-section-p #4=[org-element-deferred org-element--headline-footnote-section-p nil nil] :archivedp #5=[org-element-deferred org-element--headline-archivedp nil nil] :commentedp nil)) 0] [nil nil #9=(headline (:standard-properties [14223 14223 14238 15134 15134 0 #1# nil element t nil 14240 15132 2 nil nil nil #2#] :pre-blank 0 :raw-value [org-element-deferred org-element--headline-raw-value (3 14) t] :title #3# :level 2 :priority nil :tags nil :todo-keyword nil :todo-type nil :footnote-section-p #4# :archivedp #5# :commentedp nil)) 0] #8=(headline (:standard-properties [147 147 169 14223 14223 0 #1# section element t nil 171 14221 2 nil nil nil #2#] :pre-blank 0 :raw-value [org-element-deferred org-element--headline-raw-value (3 21) t] :title #3# :level 2 :priority nil :tags nil :todo-keyword nil :todo-type nil :footnote-section-p #4# :archivedp #5# :commentedp nil)) 0] nil nil 0] org-element--cache-compare)) ((elisp org-element--cache) . #s(avl-tree- [[[[[nil nil #6# 0] [nil nil (keyword (:standard-properties [1 1 nil nil 31 0 nil top-comment element t nil nil nil nil nil nil nil #7=(section (:standard-properties [1 1 1 118 118 0 nil first-section element t nil 1 118 nil nil nil nil #6#]))] :key "TITLE" :value "Core Packages Module")) 0] #7# 0] [[nil nil (keyword (:standard-properties [47 47 nil nil 97 0 nil nil element t nil nil nil nil nil nil nil #7#] :key "DESCRIPTION" :value "Essential packages for development")) 0] [nil nil #2# 0] (keyword (:standard-properties [97 97 nil nil 118 1 nil nil element t nil nil nil nil nil nil nil #7#] :key "STARTUP" :value "overview")) 0] (keyword (:standard-properties [31 31 nil nil 47 0 nil nil element t nil nil nil nil nil nil nil #7#] :key "AUTHOR" :value "Chris")) 0] [[nil nil #11=(section (:standard-properties [169 169 169 14223 14223 0 nil section element t nil 169 14223 nil nil nil nil #8#])) 0] [[nil nil #9# 0] [nil nil (src-block (:standard-properties [14238 14238 nil nil 15134 0 nil planning element t nil nil nil nil nil nil nil #10=(section (:standard-properties [14238 14238 14238 15134 15134 0 nil section element t nil 14238 15134 nil nil nil nil #9#]))] :language #12="emacs-lisp" :switches nil :parameters nil :number-lines nil :preserve-indent nil :retain-labels t :use-labels t :label-fmt nil :value "(defun test-core-packages-module ()\12  \"Test core packages module functionality.\"\12  (interactive)\12  (let ((results '()))\12\12    ;; Test package availability\12    (dolist (pkg '(projectile vertico consult marginalia orderless))\12      (if (featurep pkg)\12          (push (format \"%s: LOADED\" pkg) results)\12        (push (format \"%s: NOT LOADED\" pkg) results)))\12\12    ;; Test key bindings\12    (dolist (key '(\"M-x\" \"C-x b\" \"C-s\"))\12      (let ((binding (key-binding (kbd key))))\12        (push (format \"%s -> %s\" key binding) results)))\12\12    ;; Display results\12    (with-current-buffer (get-buffer-create \"*Core Packages Test*\")\12      (erase-buffer)\12      (insert \"=== Core Packages Module Test ===\\n\\n\")\12      (dolist (result (reverse results))\12        (insert (format \"%s\\n\" result)))\12      (display-buffer (current-buffer)))\12\12    (message \"Core packages test completed\")))\12")) 0] #10# 0] (src-block (:standard-properties [169 169 nil nil 14223 1 nil planning element t nil nil nil nil nil nil nil #11#] :language #12# :switches nil :parameters nil :number-lines nil :preserve-indent nil :retain-labels t :use-labels t :label-fmt nil :value ";; Projectile for project management\12(unless (package-installed-p 'projectile)\12  (package-install 'projectile))\12\12(require 'projectile)\12(projectile-mode +1)\12\12;; Vertico ecosystem - modern completion\12(unless (package-installed-p 'vertico)\12  (package-install 'vertico))\12\12(unless (package-installed-p 'consult)\12  (package-install 'consult))\12\12(unless (package-installed-p 'marginalia)\12  (package-install 'marginalia))\12\12(unless (package-installed-p 'orderless)\12  (package-install 'orderless))\12\12;; Load and configure\12(require 'vertico)\12(require 'consult)\12(require 'marginalia)\12(require 'orderless)\12\12(vertico-mode 1)\12(marginalia-mode 1)\12\12(setq completion-styles '(orderless basic)\12      completion-category-defaults nil\12      completion-category-overrides '((file (styles partial-completion))))\12\12;; Enhanced keybindings - only if functions exist\12(when (fboundp 'consult-M-x)\12  (global-set-key (kbd \"M-x\") 'consult-M-x))\12\12(when (fboundp 'consult-buffer)\12  (global-set-key (kbd \"C-x b\") 'consult-buffer))\12\12(when (fboundp 'consult-recent-file)\12  (global-set-key (kbd \"C-x C-r\") 'consult-recent-file))\12\12(when (fboundp 'consult-line)\12  (global-set-key (kbd \"C-s\") 'consult-line))\12\12;; Fallback keybindings if consult isn't available\12(unless (fboundp 'consult-recent-file)\12  (global-set-key (kbd \"C-x C-r\") 'recentf-open-files))\12\12(unless (fboundp 'consult-buffer)\12  (global-set-key (kbd \"C-x b\") 'switch-to-buffer))\12\12;; Dark company completion menu\12(with-eval-after-load 'company\12  (set-face-background 'company-tooltip \"#1e1e1e\")\12  (set-face-foreground 'company-tooltip \"#d4d4d4\")\12  (set-face-background 'company-tooltip-selection \"#264f78\")\12  (set-face-foreground 'company-tooltip-selection \"#ffffff\"))\12\12;; Install and configure ripgrep package for proper interactive search\12(unless (package-installed-p 'rg)\12  (package-install 'rg))\12\12(require 'rg)\12\12;; Configure rg package\12(setq rg-executable \"rg\")\12(setq rg-group-result t)\12(setq rg-hide-command t)\12(setq rg-show-columns nil)\12(setq rg-align-position-numbers t)\12(setq rg-align-line-number-field-length 3)\12(setq rg-align-column-number-field-length 3)\12\12;; Project-aware ripgrep function using the rg package\12(defun my-ripgrep-project (pattern)\12  \"Search in project using rg package - interactive results with jump capability.\"\12  (interactive (list (read-string \"Ripgrep project search: \")))\12  (let ((project-root (or (and (fboundp 'projectile-project-root)\12                               (projectile-project-root))\12                          ;; Fallback: look for common project markers\12                          (locate-dominating-file default-directory \".git\")\12                          (locate-dominating-file default-directory \"go.mod\")\12                          (locate-dominating-file default-directory \"CMakeLists.txt\")\12                          (locate-dominating-file default-directory \"Cargo.toml\")\12                          (locate-dominating-file default-directory \"package.json\")\12                          default-directory)))\12    (let ((default-directory project-root))\12      (rg pattern \"*\" project-root))\12    ;; Focus the rg results window\12    (run-with-timer 0.1 nil\12                    (lambda ()\12                      (let ((rg-window (get-buffer-window \"*rg*\")))\12                        (when rg-window\12                          (select-window rg-window)\12                          (goto-char (point-min))\12                          ;; Move to first result\12                          (when (re-search-forward \"^[0-9]+:\" nil t)\12                            (beginning-of-line))))))))\12\12;; Current directory ripgrep function\12(defun my-ripgrep-current-dir (pattern)\12  \"Search in current directory using rg package - interactive results.\"\12  (interactive (list (read-string \"Ripgrep current dir search: \")))\12  (rg pattern \"*\" default-directory)\12  ;; Focus the rg results window\12  (run-with-timer 0.1 nil\12                  (lambda ()\12                    (let ((rg-window (get-buffer-window \"*rg*\")))\12                      (when rg-window\12                        (select-window rg-window)\12                        (goto-char (point-min))\12                        ;; Move to first result\12                        (when (re-search-forward \"^[0-9]+:\" nil t)\12                          (beginning-of-line)))))))\12\12;; Enhanced ripgrep with preview like xref\12(defun my-ripgrep-with-preview (pattern)\12  \"Search with ripgrep and show results with interactive preview.\"\12  (interactive (list (read-string \"Ripgrep search: \")))\12  (let ((project-root (or (and (fboundp 'projectile-project-root)\12                               (projectile-project-root))\12                          (locate-dominating-file default-directory \".git\")\12                          default-directory)))\12    (rg-search-with-preview pattern \".\" project-root)))\12\12(defun rg-search-with-preview (pattern files-pattern directory)\12  \"Run ripgrep and show results with preview.\"\12  (let* ((buf (get-buffer-create \"*rg-preview*\"))\12         (original-window (selected-window))\12         (original-buffer (current-buffer))\12         (results '())\12         (default-directory directory))\12\12    ;; Run ripgrep and parse results\12    (with-temp-buffer\12      (let ((exit-code (call-process \"rg\" nil t nil\12                                     \"--line-number\"\12                                     \"--column\"\12                                     \"--no-heading\"\12                                     \"--max-depth\" \"10\"\12                                     \"--glob\" \"!test_area/src/*\"\12                                     \"--glob\" \"!build/*\"\12                                     \"--glob\" \"!.git/*\"\12                                     pattern\12                                     \".\")))\12        (if (not (= exit-code 0))\12            (message \"Ripgrep failed with exit code %d. Output: %s\" exit-code (buffer-string))\12          (message \"Ripgrep found results, parsing...\")))\12\12      (goto-char (point-min))\12      (while (not (eobp))\12        (when (looking-at \"\\\\([^:]+\\\\):\\\\([0-9]+\\\\):\\\\([0-9]+\\\\):\\\\(.*\\\\)\")\12          (let ((file-path (match-string 1)))\12            ;; Convert relative path to absolute path\12            (unless (file-name-absolute-p file-path)\12              (setq file-path (expand-file-name file-path directory)))\12            (push (list file-path  ; absolute file path\12                       (string-to-number (match-string 2))  ; line\12                       (string-to-number (match-string 3))  ; column\12                       (match-string 4)) ; content\12                  results)))\12        (forward-line 1)))\12\12    (setq results (reverse results))\12    (message \"Found %d ripgrep results\" (length results))\12\12    (when results\12      (with-current-buffer buf\12        (setq buffer-read-only nil)\12        (erase-buffer)\12        (insert \"Navigate with ↑/↓, jump with RET, quit with q\\n\")\12        (insert \"─────────────────────────────────────────────────\\n\\n\")\12\12        ;; Store data as buffer-local variables\12        (setq-local rg-preview-list results)\12        (setq-local rg-preview-index 0)\12        (setq-local rg-preview-original-window original-window)\12        (setq-local rg-preview-original-buffer original-buffer)\12        (setq-local rg-preview-current-overlay nil)\12\12        ;; Prevent auto-focus interference\12        (setq-local auto-focus-disabled t)\12\12        ;; Insert results\12        (dolist (result results)\12          (let ((file (nth 0 result))\12                (line (nth 1 result))\12                (content (nth 3 result)))\12            (insert (format \"%s:%d: %s\\n\"\12                           (file-name-nondirectory file)\12                           line\12                           content))))\12\12        (goto-char (point-min))\12        (forward-line 3) ; Skip header\12        (setq buffer-read-only t)\12\12        ;; Define local keymap\12        (let ((map (make-sparse-keymap)))\12          (define-key map (kbd \"<up>\") 'rg-preview-up)\12          (define-key map (kbd \"<down>\") 'rg-preview-down)\12          (define-key map (kbd \"p\") 'rg-preview-up)\12          (define-key map (kbd \"n\") 'rg-preview-down)\12          (define-key map (kbd \"<return>\") 'rg-preview-jump)\12          (define-key map (kbd \"RET\") 'rg-preview-jump)\12          (define-key map (kbd \"q\") 'rg-preview-quit)\12          (define-key map (kbd \"C-g\") 'rg-preview-quit)\12          (define-key map (kbd \"<escape>\") 'rg-preview-quit)\12          (use-local-map map)))\12\12      ;; Display the buffer in bottom window\12      (display-buffer buf '(display-buffer-at-bottom . ((window-height . 15))))\12      (select-window (get-buffer-window buf))\12\12      ;; Show initial preview in main window\12      (rg-preview-update-display)\12\12      ;; Clear any selection mode\12      (deactivate-mark)\12      (setq mark-active nil)\12      (setq-local transient-mark-mode nil)\12      (setq-local cua-mode nil))))\12\12(defun rg-preview-up ()\12  \"Move to previous rg result.\"\12  (interactive)\12  (when (> rg-preview-index 0)\12    (setq rg-preview-index (1- rg-preview-index))\12    (rg-preview-update-display)))\12\12(defun rg-preview-down ()\12  \"Move to next rg result.\"\12  (interactive)\12  (when (< rg-preview-index (1- (length rg-preview-list)))\12    (setq rg-preview-index (1+ rg-preview-index))\12    (rg-preview-update-display)))\12\12(defun rg-preview-jump ()\12  \"Jump to selected rg result.\"\12  (interactive)\12  (let ((result (nth rg-preview-index rg-preview-list))\12        (orig-win rg-preview-original-window)\12        (current-win (selected-window))\12        (current-buf (current-buffer))\12        (current-overlay rg-preview-current-overlay))\12\12    ;; Clean up highlight overlay\12    (when (and current-overlay (overlay-buffer current-overlay))\12      (delete-overlay current-overlay))\12\12    ;; Kill the preview buffer\12    (set-buffer-modified-p nil)\12    (kill-buffer current-buf)\12\12    ;; Close the preview window\12    (when (> (length (window-list)) 1)\12      (delete-window current-win))\12\12    ;; Jump to the location in the main window\12    (when (window-live-p orig-win)\12      (select-window orig-win))\12    (find-file (nth 0 result))\12    (goto-char (point-min))\12    (forward-line (1- (nth 1 result)))\12    (move-to-column (1- (nth 2 result)))))\12\12(defun rg-preview-quit ()\12  \"Quit rg preview.\"\12  (interactive)\12  (let ((orig-buf rg-preview-original-buffer)\12        (orig-win rg-preview-original-window)\12        (current-buf (current-buffer))\12        (current-win (selected-window))\12        (current-overlay rg-preview-current-overlay))\12\12    ;; Clean up highlight overlay\12    (when (and current-overlay (overlay-buffer current-overlay))\12      (delete-overlay current-overlay))\12\12    ;; Force kill the current buffer\12    (set-buffer-modified-p nil)\12    (kill-buffer current-buf)\12\12    ;; Close the window if it's not the only one\12    (when (> (length (window-list)) 1)\12      (delete-window current-win))\12\12    ;; Restore original state\12    (when (window-live-p orig-win)\12      (select-window orig-win))\12    (when (buffer-live-p orig-buf)\12      (switch-to-buffer orig-buf))))\12\12(defun rg-preview-update-display ()\12  \"Update the display and preview.\"\12  (let ((buf (current-buffer)))\12    ;; Update selection highlighting\12    (with-current-buffer buf\12      (setq buffer-read-only nil)\12      (goto-char (point-min))\12      (forward-line 3) ; Skip header\12\12      ;; Remove previous highlighting\12      (remove-overlays (point) (point-max) 'face)\12\12      ;; Add highlighting to current line\12      (forward-line rg-preview-index)\12      (let ((overlay (make-overlay (line-beginning-position) (line-end-position))))\12        (overlay-put overlay 'face 'highlight))\12\12      (setq buffer-read-only t))\12\12    ;; Update preview in main window\12    (when (< rg-preview-index (length rg-preview-list))\12      (rg-preview-show-location-in-main (nth rg-preview-index rg-preview-list) rg-preview-original-window))))\12\12(defun rg-preview-show-location-in-main (result original-window)\12  \"Show ripgrep result in the main window.\"\12  (let* ((file (nth 0 result))\12         (line (nth 1 result))\12         (column (nth 2 result))\12         (preview-buf (get-buffer \"*rg-preview*\")))\12\12    (with-selected-window original-window\12\12      ;; Clean up previous overlay first\12      (when (and preview-buf\12                 (buffer-local-value 'rg-preview-current-overlay preview-buf))\12        (let ((old-overlay (buffer-local-value 'rg-preview-current-overlay preview-buf)))\12          (when (and old-overlay (overlay-buffer old-overlay))\12            (delete-overlay old-overlay))))\12\12      (find-file file)\12      (goto-char (point-min))\12      (forward-line (1- line))\12      (move-to-column (1- column))\12      (recenter)\12\12      ;; Create highlight overlay for the line in main window\12      (let ((overlay (make-overlay (line-beginning-position) (line-end-position))))\12        (overlay-put overlay 'face '(:background \"#3a3a3a\" :foreground \"white\"))\12\12        ;; Store the overlay reference in the preview buffer for cleanup\12        (when preview-buf\12          (with-current-buffer preview-buf\12            (setq-local rg-preview-current-overlay overlay)))))))\12\12;; Ripgrep keybindings - now with preview\12(global-set-key (kbd \"C-c r\") 'my-ripgrep-with-preview)     ; C-c r = ripgrep project with preview\12(global-set-key (kbd \"C-c R\") 'my-ripgrep-current-dir)      ; C-c R = ripgrep current directory\12(global-set-key (kbd \"C-c g\") 'rg-menu)                     ; C-c g = ripgrep menu for advanced options\12\12;; Header/Implementation switcher - use ff-find-other-file (built-in)\12;; This is more reliable than external packages\12(global-set-key (kbd \"C-x z\") 'ff-find-other-file)\12(message \"Header/implementation switcher (ff-find-other-file) configured (C-x z)\")\12\12;; Debug: Show what's actually bound\12(message \"C-x C-r bound to: %s\" (key-binding (kbd \"C-x C-r\")))\12(message \"C-x b bound to: %s\" (key-binding (kbd \"C-x b\")))\12\12;; Company for completions (must be before eglot)\12(unless (package-installed-p 'company)\12  (package-install 'company))\12\12(require 'company)\12(global-company-mode 1)\12(setq company-idle-delay 0.1)\12(setq company-minimum-prefix-length 1)\12\12;; Eglot for LSP\12(require 'eglot)\12(add-to-list 'eglot-server-programs '(c-mode . (\"clangd\")))\12(add-hook 'c-mode-hook 'eglot-ensure)\12")) 1] #8# 0] nil nil 0] org-element--cache-compare)) ((version "2.3")))