#+TITLE: Emacs Configuration for C11 Development
#+AUTHOR: Chris
#+DESCRIPTION: Literate Emacs configuration using org-mode for C11 development with LSP
#+STARTUP: overview

* Introduction
This is a literate Emacs configuration written in org-mode for C11 development.
The configuration includes LSP support via Eglot, quick build commands, and a clean setup.

* Basic Settings
** Startup and UI
Clean up the default Emacs interface for a minimal development environment.

#+BEGIN_SRC emacs-lisp
;; Basic settings
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)

;; Replace default scratch buffer with persistent org-mode scratch
(setq initial-major-mode 'org-mode)            ; Start scratch in org-mode
(setq initial-buffer-choice                    ; Use custom scratch buffer
      (lambda () (get-buffer-create "*scratch*")))

;; Session persistence - remember everything automatically
(desktop-save-mode 1)                          ; Save/restore buffers and window config
(setq desktop-restore-eager 5)                 ; Restore first 5 buffers immediately
(setq desktop-lazy-verbose nil)                ; Don't show messages for lazy loading
(setq desktop-save t)                          ; Always save session
(setq desktop-load-locked-desktop t)           ; Load even if locked

;; Remember recent files
(recentf-mode 1)
(setq recentf-max-saved-items 100)             ; Remember 100 recent files
(setq recentf-auto-cleanup 'never)             ; Don't cleanup automatically

;; Remember minibuffer history
(savehist-mode 1)
(setq savehist-additional-variables            ; Save additional useful variables
      '(search-ring regexp-search-ring))

;; Remember cursor position in files
(save-place-mode 1)

;; Persistent org-mode scratch buffer
(defun save-persistent-scratch ()
  "Save the org scratch buffer to disk."
  (with-current-buffer "*scratch*"
    (write-region (point-min) (point-max)
                  (expand-file-name "scratch.org" user-emacs-directory))))

(defun load-persistent-scratch ()
  "Load the persistent org scratch buffer from disk."
  (let ((scratch-file (expand-file-name "scratch.org" user-emacs-directory)))
    (with-current-buffer "*scratch*"
      (erase-buffer)
      (if (file-exists-p scratch-file)
          (insert-file-contents scratch-file)
        ;; Create initial org-mode scratch content
        (insert "#+TITLE: Scratch Notes\n")
        (insert "#+AUTHOR: Chris\n")
        (insert "#+DATE: " (format-time-string "%Y-%m-%d") "\n\n")
        (insert "* Quick Notes\n\n")
        (insert "* Code Experiments\n\n")
        (insert "#+BEGIN_SRC emacs-lisp\n")
        (insert ";; Evaluate with C-c C-c\n")
        (insert "(+ 1 2 3)\n")
        (insert "#+END_SRC\n\n")
        (insert "* TODO Items\n")
        (insert "- [ ] Task 1\n")
        (insert "- [ ] Task 2\n\n"))
      (org-mode)
      (goto-char (point-min)))))

;; Auto-save org scratch buffer periodically
(run-with-idle-timer 30 t 'save-persistent-scratch)  ; Save every 30 seconds when idle

;; Initialize org-mode scratch on startup
(add-hook 'after-init-hook
          (lambda ()
            ;; Kill default scratch if it exists
            (when (get-buffer "*scratch*")
              (with-current-buffer "*scratch*"
                (when (eq major-mode 'lisp-interaction-mode)
                  (erase-buffer))))
            ;; Load our persistent org scratch
            (load-persistent-scratch)))

;; Save scratch on exit
(add-hook 'kill-emacs-hook 'save-persistent-scratch)

;; Create org scratch buffer function
(defun create-scratch-buffer ()
  "Create or switch to persistent org-mode scratch buffer."
  (interactive)
  (switch-to-buffer "*scratch*")
  (unless (eq major-mode 'org-mode)
    (org-mode)))

(global-set-key (kbd "C-c s c") 'create-scratch-buffer)

;; Basic UI cleanup
(menu-bar-mode -1)
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

;; Show line numbers
(global-display-line-numbers-mode 1)

;; Disable annoying audible bell
(setq ring-bell-function 'ignore)              ; Completely disable bell
(setq visible-bell nil)                        ; No visual bell either (clean)
#+END_SRC

** File Management
Prevent Emacs from creating clutter files like backups and auto-saves.

#+BEGIN_SRC emacs-lisp
;; Backup and auto-save settings - no clutter files
(setq make-backup-files nil)            ; No backup files (file~)
(setq auto-save-default nil)            ; No auto-save files (#file#)
(setq create-lockfiles nil)             ; No lock files (.#file)
#+END_SRC

** Editing Defaults
Basic editing preferences for consistent code style.

#+BEGIN_SRC emacs-lisp
;; Basic editing
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+END_SRC

* Package Management
** Repository Setup
Configure package repositories and disable signature verification for Windows compatibility.

#+BEGIN_SRC emacs-lisp
;; Package management
(require 'package)
(setq package-archives
      '(("gnu" . "https://elpa.gnu.org/packages/")
        ("melpa" . "https://melpa.org/packages/")))

;; Disable package signature verification to avoid GPG issues
(setq package-check-signature nil)

(package-initialize)

;; Refresh package contents if needed
(unless package-archive-contents
  (package-refresh-contents))
#+END_SRC

** Theme Installation
Install and configure the voidlight theme for comfortable dark coding.

#+BEGIN_SRC emacs-lisp
;; Download and install voidlight theme manually from GitHub
(let ((theme-dir (expand-file-name "themes" user-emacs-directory))
      (theme-file (expand-file-name "themes/voidlight-theme.el" user-emacs-directory)))

  ;; Create themes directory if it doesn't exist
  (unless (file-directory-p theme-dir)
    (make-directory theme-dir t))

  ;; Download theme file if it doesn't exist
  (unless (file-exists-p theme-file)
    (url-copy-file "https://raw.githubusercontent.com/christerso/emacs-voidlight-theme/main/voidlight-theme.el"
                   theme-file t))

  ;; Add themes directory to custom theme load path
  (add-to-list 'custom-theme-load-path theme-dir)

  ;; Load the voidlight theme
  (load-theme 'voidlight t))
#+END_SRC

** Font Configuration
Configure a beautiful Nerd Font for optimal programming experience with icons and ligatures.

#+BEGIN_SRC emacs-lisp
;; Set default font to JetBrains Mono Nerd Font
;; Download from: https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip
(when (member "JetBrainsMono Nerd Font" (font-family-list))
  (set-face-attribute 'default nil :family "JetBrainsMono Nerd Font" :height 110)
  (set-face-attribute 'fixed-pitch nil :family "JetBrainsMono Nerd Font" :height 110))

;; Fallback fonts if JetBrains Mono Nerd Font is not available
(unless (member "JetBrainsMono Nerd Font" (font-family-list))
  (cond
   ;; Try Cascadia Code (Windows 11 default, has ligatures)
   ((member "Cascadia Code" (font-family-list))
    (set-face-attribute 'default nil :family "Cascadia Code" :height 110))
   ;; Try Fira Code (popular programming font)
   ((member "Fira Code" (font-family-list))
    (set-face-attribute 'default nil :family "Fira Code" :height 110))
   ;; Fallback to Consolas (Windows default monospace)
   ((member "Consolas" (font-family-list))
    (set-face-attribute 'default nil :family "Consolas" :height 110))))
#+END_SRC

* Development Environment
** Windows PATH Configuration
Set up the Windows environment to find clangd and other development tools.

#+BEGIN_SRC emacs-lisp
;; PATH setup for Windows
(when (eq system-type 'windows-nt)
  (setenv "PATH" (concat "C:\\Program Files\\LLVM\\bin;"
                         "C:\\Users\\chris\\go\\bin;"
                         (getenv "PATH")))
  (setq exec-path (append '("C:\\Program Files\\LLVM\\bin"
                           "C:\\Users\\chris\\go\\bin")
                         exec-path)))
#+END_SRC

** LSP Configuration with Eglot
Configure Eglot (built-in LSP client) for C development with clangd.
Automatically starts when opening C files.

#+BEGIN_SRC emacs-lisp
;; Eglot LSP setup
(require 'eglot)

;; Configure clangd for C files
(add-to-list 'eglot-server-programs '(c-mode . ("clangd")))

;; Automatically start Eglot for C files
(add-hook 'c-mode-hook 'eglot-ensure)

;; Disable problematic flymake backends completely (we use Eglot for diagnostics)
(with-eval-after-load 'flymake
  (setq flymake-cc-command nil)                           ; Disable flymake-cc command
  (remove-hook 'flymake-diagnostic-functions 'flymake-cc) ; Remove from functions
  (when (fboundp 'flymake-cc)
    (fmakunbound 'flymake-cc)))                           ; Remove function entirely

;; Also disable flymake completely in C mode since we use Eglot
(add-hook 'c-mode-hook
          (lambda ()
            (flymake-mode -1)))  ; Disable flymake, use Eglot diagnostics instead

;; Automatic file headers
(defun insert-c-header ()
  "Insert standard C file header for new files."
  (when (and (buffer-file-name)
             (= (point-min) (point-max))  ; Empty file
             (string-match-p "\\.\\(c\\|h\\)$" (buffer-file-name)))
    (let ((filename (file-name-nondirectory (buffer-file-name)))
          (is-header (string-match-p "\\.h$" (buffer-file-name))))
      (insert (format "/**\n"))
      (insert (format " * @file %s\n" filename))
      (insert (format " * @brief \n"))
      (insert (format " * @author Christer Söderlund <christer.soderlund@gmail.com>\n"))
      (insert (format " * @date %s\n" (format-time-string "%Y-%m-%d")))
      (insert (format " * @copyright Copyright (c) %s Christer Söderlund\n" (format-time-string "%Y")))
      (insert (format " */\n\n"))

      (when is-header
        (let ((guard-name (upcase (replace-regexp-in-string "[^a-zA-Z0-9]" "_"
                                                           (file-name-sans-extension filename)))))
          (insert (format "#ifndef %s_H\n" guard-name))
          (insert (format "#define %s_H\n\n" guard-name))
          (insert "#ifdef __cplusplus\n")
          (insert "extern \"C\" {\n")
          (insert "#endif\n\n")
          (insert "// Header content here\n\n")
          (insert "#ifdef __cplusplus\n")
          (insert "}\n")
          (insert "#endif\n\n")
          (insert (format "#endif // %s_H\n" guard-name))))

      (goto-char (point-min))
      (search-forward "@brief ")
      (message "C header inserted - fill in @brief description"))))

(defun insert-go-header ()
  "Insert standard Go file header for new files."
  (when (and (buffer-file-name)
             (= (point-min) (point-max))  ; Empty file
             (string-match-p "\\.go$" (buffer-file-name)))
    (let ((filename (file-name-nondirectory (buffer-file-name)))
          (package-name (file-name-nondirectory (directory-file-name default-directory))))
      (insert (format "// Package %s \n" package-name))
      (insert (format "// File: %s\n" filename))
      (insert (format "// Author: Christer Söderlund <christer.soderlund@gmail.com>\n"))
      (insert (format "// Date: %s\n" (format-time-string "%Y-%m-%d")))
      (insert (format "// Copyright (c) %s Christer Söderlund\n\n" (format-time-string "%Y")))
      (insert (format "package %s\n\n" package-name))
      (goto-char (point-min))
      (search-forward "Package ")
      (message "Go header inserted - fill in package description"))))
#+END_SRC

** C Language Settings
Configure C-specific editing preferences and style.

#+BEGIN_SRC emacs-lisp
;; C-specific settings
(add-hook 'c-mode-hook
          (lambda ()
            (setq c-default-style "k&r")
            (setq c-basic-offset 2)    ; Use 2 spaces for C (more standard)
            ;; Insert header for new files
            (insert-c-header)
            ;; Auto-format C files when opened (after brief delay)
            (run-with-idle-timer 0.5 nil 'format-buffer)))  ; Format after 0.5s delay

;; Autoformatting with clang-format
(defun format-buffer ()
  "Format the current buffer using clang-format with C-specific style."
  (interactive)
  (when (eq major-mode 'c-mode)
    (let ((start-point (point))
          (start-line (line-number-at-pos))
          (original-content (buffer-string)))
      (condition-case err
          (progn
            (let ((formatted-content
                   (with-temp-buffer
                     (insert original-content)
                     (let ((exit-code (call-process-region (point-min) (point-max)
                                                          "clang-format" t t nil
                                                          "--style={BasedOnStyle: Google, ColumnLimit: 120, IndentWidth: 2}"
                                                          "--assume-filename=.c")))
                       (if (= exit-code 0)
                           (buffer-string)
                         (error "clang-format failed with exit code %d" exit-code))))))
              (erase-buffer)
              (insert formatted-content)
              (goto-line start-line)
              (message "Buffer formatted with clang-format")))
        (error
         (erase-buffer)
         (insert original-content)
         (goto-char start-point)
         (message "Formatting failed, buffer restored: %s" (error-message-string err)))))))

;; Format current file and save
(defun format-and-save ()
  "Format the current buffer and save it."
  (interactive)
  (format-buffer)
  (save-buffer)
  (message "File formatted and saved"))

;; Format on save (optional - uncomment if you want auto-format on save)
;; (add-hook 'c-mode-hook
;;           (lambda ()
;;             (add-hook 'before-save-hook 'format-buffer nil t)))

;; Key bindings for formatting
(global-set-key (kbd "C-c f") 'format-buffer)        ; Format current buffer
(global-set-key (kbd "C-c F") 'format-and-save)      ; Format and save

;; Auto-close compilation window on success, keep open on failure
(defun my-compilation-finish-function (buffer status)
  "Close compilation buffer if successful, keep open if failed."
  (let ((window (get-buffer-window buffer)))
    (cond
     ;; Success - close window after brief delay
     ((string-match "finished" status)
      (run-with-timer 1.0 nil
                      (lambda ()
                        (when (get-buffer-window buffer)
                          (delete-window (get-buffer-window buffer)))
                        (message "Build successful - compilation window closed"))))
     ;; Failure - keep window open and show message
     ((string-match "exited abnormally" status)
      (message "Build failed - check compilation buffer for errors"))
     ;; Other statuses - do nothing
     (t nil))))

(add-hook 'compilation-finish-functions 'my-compilation-finish-function)

;; Better compilation window behavior
(setq compilation-window-height 15)           ; Reasonable window height
(setq compilation-scroll-output 'first-error) ; Scroll to first error
#+END_SRC

** Go Language Settings
Configure Go development with gopls LSP and modern tooling.

#+BEGIN_SRC emacs-lisp
;; Go mode
(unless (package-installed-p 'go-mode)
  (package-install 'go-mode))

(require 'go-mode)

;; Configure gopls for Go files
(add-to-list 'eglot-server-programs '(go-mode . ("gopls")))

;; Automatically start Eglot for Go files
(add-hook 'go-mode-hook 'eglot-ensure)

;; Go-specific settings
(add-hook 'go-mode-hook
          (lambda ()
            (setq tab-width 4)                    ; Go uses tabs, 4-space width
            (setq indent-tabs-mode t)             ; Use actual tabs for Go
            (setq go-ts-mode-indent-offset 4)     ; Consistent indentation
            ;; Insert header for new Go files
            (insert-go-header)))

;; Go formatting with goimports (better than gofmt)
(defun go-format-buffer ()
  "Format Go buffer with goimports."
  (interactive)
  (when (eq major-mode 'go-mode)
    (let ((start-point (point))
          (start-line (line-number-at-pos))
          (original-content (buffer-string)))
      (condition-case err
          (progn
            (let ((formatted-content
                   (with-temp-buffer
                     (insert original-content)
                     (let ((exit-code (call-process-region (point-min) (point-max)
                                                          "goimports" t t nil)))
                       (if (= exit-code 0)
                           (buffer-string)
                         (error "goimports failed with exit code %d" exit-code))))))
              (erase-buffer)
              (insert formatted-content)
              (goto-line start-line)
              (message "Go buffer formatted with goimports")))
        (error
         (erase-buffer)
         (insert original-content)
         (goto-char start-point)
         (message "Go formatting failed, buffer restored: %s" (error-message-string err)))))))

;; Go format and save
(defun go-format-and-save ()
  "Format Go buffer and save it."
  (interactive)
  (go-format-buffer)
  (save-buffer))

;; Key bindings for Go formatting
(define-key go-mode-map (kbd "C-c f") 'go-format-buffer)    ; Format Go buffer
(define-key go-mode-map (kbd "C-c F") 'go-format-and-save)  ; Format and save

;; Auto-format Go files on save (optional - uncomment if desired)
;; (add-hook 'go-mode-hook
;;           (lambda ()
;;             (add-hook 'before-save-hook 'go-format-buffer nil t)))
#+END_SRC

* Build System Integration
** Dream Project Build & Run Commands
Quick build, run, and debug functions for the Dream project.

#+BEGIN_SRC emacs-lisp
;; Smart build command - detects project type
(defun smart-build ()
  "Build project using appropriate build system based on project type."
  (interactive)
  (let* ((project-root (or (projectile-project-root) default-directory))
         (cmake-file (expand-file-name "CMakeLists.txt" project-root))
         (go-mod-file (expand-file-name "go.mod" project-root))
         (go-files (directory-files project-root nil "\\.go$")))

    (cond
     ;; CMake project (like Dream)
     ((file-exists-p cmake-file)
      (let ((default-directory project-root))
        (compile "cmake --build build --config Release")))

     ;; Go project with go.mod
     ((file-exists-p go-mod-file)
      (let ((default-directory project-root))
        (compile "go build -v ./...")))

     ;; Go files without go.mod (single file)
     ((and go-files (eq major-mode 'go-mode))
      (let ((current-file (buffer-file-name)))
        (compile (format "go build -v %s" (file-name-nondirectory current-file)))))

     ;; C file without CMake (single file compile)
     ((eq major-mode 'c-mode)
      (let ((current-file (buffer-file-name)))
        (compile (format "clang -std=c11 -o %s %s"
                        (file-name-sans-extension (file-name-nondirectory current-file))
                        (file-name-nondirectory current-file)))))

     ;; Default fallback
     (t
      (message "No recognized build system found in project")))))

;; Keep dream-specific build for explicit use
(defun dream-build ()
  "Build the dream project using CMake."
  (interactive)
  (let ((default-directory "G:/repos/dream/"))
    (compile "cmake --build build --config Release --target dream")))

;; Smart run command - detects project type and runs appropriately
(defun smart-run ()
  "Run project using appropriate method based on project type."
  (interactive)
  (let* ((project-root (or (projectile-project-root) default-directory))
         (cmake-file (expand-file-name "CMakeLists.txt" project-root))
         (go-mod-file (expand-file-name "go.mod" project-root))
         (go-files (directory-files project-root nil "\\.go$")))

    (cond
     ;; Dream CMake project (specific handling)
     ((and (file-exists-p cmake-file)
           (string-match-p "dream" project-root))
      (let ((exe-path (expand-file-name "build/Release/dream.exe" project-root)))
        (if (file-exists-p exe-path)
            (let ((default-directory project-root))
              (async-shell-command exe-path "*Dream Output*"))
          (message "Dream executable not found. Build first with F3."))))

     ;; Generic CMake project
     ((file-exists-p cmake-file)
      (let* ((build-dir (expand-file-name "build" project-root))
             (exe-files (when (file-directory-p build-dir)
                         (directory-files-recursively build-dir "\\.exe$"))))
        (if exe-files
            (let ((exe-to-run (car exe-files)))  ; Use first executable found
              (async-shell-command exe-to-run "*CMake Output*"))
          (message "No executable found. Build first with F3."))))

     ;; Go project with go.mod
     ((file-exists-p go-mod-file)
      (let ((default-directory project-root))
        (async-shell-command "go run ." "*Go Output*")))

     ;; Single Go file
     ((and go-files (eq major-mode 'go-mode))
      (let ((current-file (buffer-file-name)))
        (async-shell-command (format "go run %s" (file-name-nondirectory current-file))
                             "*Go Output*")))

     ;; Single C file
     ((eq major-mode 'c-mode)
      (let* ((current-file (buffer-file-name))
             (exe-name (file-name-sans-extension (file-name-nondirectory current-file))))
        (if (file-exists-p (concat exe-name ".exe"))
            (async-shell-command (format "./%s.exe" exe-name) "*C Output*")
          (message "Executable not found. Build first with F3."))))

     ;; Default fallback
     (t
      (message "No recognized run method for current project")))))

;; Smart debug command - detects project type and debugs appropriately
(defun smart-debug ()
  "Debug project using appropriate debugger based on project type."
  (interactive)
  (let* ((project-root (or (projectile-project-root) default-directory))
         (cmake-file (expand-file-name "CMakeLists.txt" project-root))
         (go-mod-file (expand-file-name "go.mod" project-root))
         (remedybg-path "C:/remedybg.exe"))

    (cond
     ;; Dream CMake project (RemedyBG)
     ((and (file-exists-p cmake-file)
           (string-match-p "dream" project-root))
      (let ((exe-path (expand-file-name "build/Release/dream.exe" project-root)))
        (if (file-exists-p exe-path)
            (if (file-exists-p remedybg-path)
                (async-shell-command (format "\"%s\" \"%s\"" remedybg-path exe-path))
              (message "RemedyBG not found at C:/remedybg.exe"))
          (message "Dream executable not found. Build first with F3."))))

     ;; Generic CMake project (try RemedyBG or Visual Studio)
     ((file-exists-p cmake-file)
      (let* ((build-dir (expand-file-name "build" project-root))
             (exe-files (when (file-directory-p build-dir)
                         (directory-files-recursively build-dir "\\.exe$"))))
        (if exe-files
            (let ((exe-to-debug (car exe-files)))
              (if (file-exists-p remedybg-path)
                  (async-shell-command (format "\"%s\" \"%s\"" remedybg-path exe-to-debug))
                (message "RemedyBG not found. Install for debugging support.")))
          (message "No executable found for debugging. Build first with F3."))))

     ;; Go project (use delve debugger)
     ((or (file-exists-p go-mod-file) (eq major-mode 'go-mode))
      (let ((default-directory project-root))
        (async-shell-command "dlv debug" "*Go Debug*")))

     ;; Default fallback
     (t
      (message "No recognized debug method for current project")))))

;; Keep original dream functions for explicit use
(defun dream-build ()
  "Build the dream project using CMake."
  (interactive)
  (let ((default-directory "G:/repos/dream/"))
    (compile "cmake --build build --config Release --target dream")))

(defun dream-run ()
  "Run the compiled dream project executable."
  (interactive)
  (let ((default-directory "G:/repos/dream/")
        (exe-path "G:/repos/dream/build/Release/dream.exe"))
    (if (file-exists-p exe-path)
        (async-shell-command exe-path "*Dream Output*")
      (message "Dream executable not found. Build first with F3."))))

(defun dream-debug ()
  "Debug the dream project using RemedyBG."
  (interactive)
  (let ((default-directory "G:/repos/dream/")
        (exe-path "G:/repos/dream/build/Release/dream.exe")
        (remedybg-path "C:/remedybg.exe"))
    (if (file-exists-p exe-path)
        (if (file-exists-p remedybg-path)
            (async-shell-command (format "\"%s\" \"%s\"" remedybg-path exe-path))
          (message "RemedyBG not found at C:/remedybg.exe"))
      (message "Dream executable not found. Build first with F3."))))

;; Key bindings for build/run/debug workflow
(global-set-key [f3] 'smart-build)        ; F3 = Smart Build (detects project type)
(global-set-key [f4] 'smart-run)          ; F4 = Smart Run (detects project type)
(global-set-key [S-f4] 'smart-debug)      ; Shift+F4 = Smart Debug (detects project type)

;; Explicit Dream project functions (backup)
(global-set-key [f5] 'dream-build)        ; F5 = Dream-specific build
(global-set-key [f6] 'dream-run)          ; F6 = Dream-specific run
(global-set-key [S-f6] 'dream-debug)      ; Shift+F6 = Dream-specific debug
#+END_SRC

* Developer Tools
** Markdown Support
Enhanced markdown editing with live preview and toggle view.

#+BEGIN_SRC emacs-lisp
;; Markdown mode with live preview
(unless (package-installed-p 'markdown-mode)
  (package-install 'markdown-mode))

(unless (package-installed-p 'markdown-preview-mode)
  (package-install 'markdown-preview-mode))

(unless (package-installed-p 'grip-mode)
  (package-install 'grip-mode))

(require 'markdown-mode)
(require 'markdown-preview-mode)
(require 'grip-mode)

;; File associations
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))

;; Markdown configuration - pandoc is now installed
(setq markdown-command "pandoc")  ; Use pandoc for high-quality rendering
(setq markdown-preview-style "github")  ; GitHub-style preview
(setq markdown-fontify-code-blocks-natively t)  ; Syntax highlight code blocks

;; Custom markdown preview function - fixed
(defun my-markdown-toggle-preview ()
  "Toggle between markdown source and rendered preview."
  (interactive)
  (if (get-buffer "*markdown-preview*")
      (markdown-preview-cleanup)  ; Close preview
    (markdown-preview)))         ; Open preview

;; GitHub-style preview with grip (requires GitHub token for unlimited use)
(defun my-markdown-grip-toggle ()
  "Toggle GitHub-style preview with grip."
  (interactive)
  (if grip-mode
      (grip-stop-preview)
    (grip-start-preview)))

;; Full-window markdown preview with q to quit
(defun my-markdown-split-preview ()
  "Show markdown preview in full window, press q to return."
  (interactive)
  (let ((preview-buffer "*Markdown Preview*")
        (source-buffer (current-buffer))
        (source-window-config (current-window-configuration)))

    ;; Store the source buffer and window configuration
    (setq markdown-preview-source-buffer source-buffer)
    (setq markdown-preview-window-config source-window-config)

    ;; Create and switch to preview buffer
    (switch-to-buffer (get-buffer-create preview-buffer))

    ;; Clear and populate preview buffer
    (let ((inhibit-read-only t))
      (erase-buffer)
      (let ((markdown-content (with-current-buffer source-buffer (buffer-string))))
        (insert markdown-content)
        (shell-command-on-region (point-min) (point-max) "pandoc -f markdown -t plain" t t)
        (goto-char (point-min))
        (deactivate-mark)))  ; Clear any selection/highlighting

    ;; Set up preview mode with colorization
    (text-mode)  ; Use text-mode as base
    (my-markdown-colorize-preview)  ; Add custom colorization
    (read-only-mode 1)
    (setq buffer-read-only t)
    (goto-char (point-min))  ; Ensure cursor at top
    (deactivate-mark)  ; Clear selection again

    ;; Local key bindings for preview
    (use-local-map (copy-keymap (current-local-map)))
    (local-set-key (kbd "q") 'my-markdown-preview-quit)
    (local-set-key (kbd "r") 'my-markdown-preview-refresh)

    (message "Markdown Preview - Press 'q' to quit, 'r' to refresh")))

;; Colorization function for markdown preview
(defun my-markdown-colorize-preview ()
  "Add colorization to the markdown preview buffer."
  (let ((inhibit-read-only t))
    (save-excursion
      ;; Enable font-lock mode for colorization
      (font-lock-mode 1)

      ;; Colorize function keywords (theme blue)
      (goto-char (point-min))
      (when (re-search-forward "\\(FUNCTION\\|function\\|def\\|struct\\)" nil t)
        (put-text-property (match-beginning 1) (match-end 1) 'face
                           '(:foreground "#569cd6" :weight bold)))

      ;; Colorize ALL CAPS words (light gray/white)
      (goto-char (point-min))
      (while (re-search-forward "\\b[A-Z][A-Z_]+[A-Z]\\b" nil t)
        (put-text-property (match-beginning 0) (match-end 0) 'face
                           '(:foreground "#d4d4d4" :weight bold)))

      ;; Colorize numbers (soft orange)
      (goto-char (point-min))
      (while (re-search-forward "\\b[0-9]+\\b" nil t)
        (put-text-property (match-beginning 0) (match-end 0) 'face
                           '(:foreground "#ce9178")))

      ;; Colorize code-like patterns (theme light blue)
      (goto-char (point-min))
      (while (re-search-forward "\\b[a-zA-Z_][a-zA-Z0-9_]*_[a-zA-Z0-9_]*\\b" nil t)
        (put-text-property (match-beginning 0) (match-end 0) 'face
                           '(:foreground "#9cdcfe" :family "JetBrainsMono Nerd Font")))

      ;; Colorize function calls (light white)
      (goto-char (point-min))
      (while (re-search-forward "\\b[a-zA-Z_][a-zA-Z0-9_]*(" nil t)
        (put-text-property (match-beginning 0) (1- (match-end 0)) 'face
                           '(:foreground "#dcdcdc" :family "JetBrainsMono Nerd Font")))

      ;; Colorize bullet points and dashes (theme keyword blue)
      (goto-char (point-min))
      (while (re-search-forward "^[ ]*\\([-*•]\\|[0-9]+\\.\\)" nil t)
        (put-text-property (match-beginning 1) (match-end 1) 'face
                           '(:foreground "#569cd6" :weight bold)))

      ;; Force redisplay
      (font-lock-ensure))))

;; Helper functions for preview mode
(defun my-markdown-preview-quit ()
  "Quit markdown preview and return to source buffer."
  (interactive)
  (when (boundp 'markdown-preview-window-config)
    (set-window-configuration markdown-preview-window-config))
  (when (boundp 'markdown-preview-source-buffer)
    (switch-to-buffer markdown-preview-source-buffer))
  (kill-buffer "*Markdown Preview*")
  (message "Returned to markdown source"))

(defun my-markdown-preview-refresh ()
  "Refresh the markdown preview."
  (interactive)
  (when (boundp 'markdown-preview-source-buffer)
    (let ((inhibit-read-only t)
          (source-buffer markdown-preview-source-buffer))
      (erase-buffer)
      (let ((markdown-content (with-current-buffer source-buffer (buffer-string))))
        (insert markdown-content)
        (shell-command-on-region (point-min) (point-max) "pandoc -f markdown -t plain" t t)
        (my-markdown-colorize-preview)  ; Apply colorization after refresh
        (goto-char (point-min))
        (deactivate-mark))  ; Clear any selection after refresh
      (message "Preview refreshed"))))

;; Key bindings for markdown
(define-key markdown-mode-map (kbd "C-c C-p") 'my-markdown-toggle-preview)      ; Browser preview
(define-key markdown-mode-map (kbd "C-c C-g") 'my-markdown-grip-toggle)         ; GitHub preview
(define-key markdown-mode-map (kbd "C-c C-v") 'markdown-preview-mode)           ; Original preview mode
(define-key markdown-mode-map (kbd "C-c C-s") 'my-markdown-split-preview)       ; Split window preview (main one)

;; Auto-close preview when markdown buffer is killed
(add-hook 'kill-buffer-hook
          (lambda ()
            (when (eq major-mode 'markdown-mode)
              (markdown-preview-cleanup))))

;; Enhanced markdown editing
(add-hook 'markdown-mode-hook
          (lambda ()
            (visual-line-mode 1)        ; Wrap lines visually
            ;; (flyspell-mode 1)        ; Spell checking - disabled until ispell installed
            (setq-local fill-column 80) ; Line width for hard wrapping
            ;; Fix ugly fonts in markdown mode - aggressive approach
            (when (member "JetBrainsMono Nerd Font" (font-family-list))
              (set-face-attribute 'markdown-code-face nil
                                  :family "JetBrainsMono Nerd Font" :height 110)
              (set-face-attribute 'markdown-inline-code-face nil
                                  :family "JetBrainsMono Nerd Font" :height 110)
              (set-face-attribute 'markdown-pre-face nil
                                  :family "JetBrainsMono Nerd Font" :height 110)
              (set-face-attribute 'fixed-pitch nil
                                  :family "JetBrainsMono Nerd Font" :height 110)
              ;; Force buffer-specific font
              (setq buffer-face-mode-face '(:family "JetBrainsMono Nerd Font" :height 110))
              (buffer-face-mode 1))))

;; Live preview configuration
(setq markdown-preview-javascript
      (list "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"
            "https://cdn.jsdelivr.net/npm/prismjs@1.28.0/components/prism-core.min.js"
            "https://cdn.jsdelivr.net/npm/prismjs@1.28.0/plugins/autoloader/prism-autoloader.min.js"))

(setq markdown-preview-stylesheets
      (list "https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.css"
            "https://cdn.jsdelivr.net/npm/prismjs@1.28.0/themes/prism.css"))
#+END_SRC

** Window Navigation
Fast window switching with arrow keys.

#+BEGIN_SRC emacs-lisp
;; Window navigation with Ctrl+Alt+arrows (like modern IDEs)
(global-set-key (kbd "C-M-<left>") 'windmove-left)    ; Ctrl+Alt+Left
(global-set-key (kbd "C-M-<right>") 'windmove-right)  ; Ctrl+Alt+Right
(global-set-key (kbd "C-M-<up>") 'windmove-up)        ; Ctrl+Alt+Up
(global-set-key (kbd "C-M-<down>") 'windmove-down)    ; Ctrl+Alt+Down

;; Alternative: Use Shift+Arrow for window movement (if Ctrl+Alt conflicts)
(global-set-key (kbd "S-<left>") 'windmove-left)      ; Shift+Left
(global-set-key (kbd "S-<right>") 'windmove-right)    ; Shift+Right
(global-set-key (kbd "S-<up>") 'windmove-up)          ; Shift+Up
(global-set-key (kbd "S-<down>") 'windmove-down)      ; Shift+Down

;; Window management shortcuts
(global-set-key (kbd "C-x 2") 'split-window-below)    ; Split horizontally
(global-set-key (kbd "C-x 3") 'split-window-right)    ; Split vertically
(global-set-key (kbd "C-x 0") 'delete-window)         ; Close current window
(global-set-key (kbd "C-x 1") 'delete-other-windows)  ; Close all other windows

;; Buffer navigation (complement to window navigation)
(global-set-key (kbd "C-<tab>") 'next-buffer)         ; Ctrl+Tab (next buffer)
(global-set-key (kbd "C-S-<tab>") 'previous-buffer)   ; Ctrl+Shift+Tab (previous buffer)

;; Improved buffer list that auto-jumps for selection
(defun my-buffer-list-and-switch ()
  "Show buffer list in current window for immediate selection."
  (interactive)
  (switch-to-buffer (list-buffers-noselect)))

(global-set-key (kbd "C-x C-b") 'my-buffer-list-and-switch)  ; Auto-jump to buffer list

;; Window resizing with Ctrl+Shift+arrows
(global-set-key (kbd "C-S-<left>") 'shrink-window-horizontally)   ; Make window narrower
(global-set-key (kbd "C-S-<right>") 'enlarge-window-horizontally) ; Make window wider
(global-set-key (kbd "C-S-<up>") 'shrink-window)                  ; Make window shorter
(global-set-key (kbd "C-S-<down>") 'enlarge-window)               ; Make window taller

;; Enable windmove wrapping (cycle through windows)
(setq windmove-wrap-around t)

;; Disable annoying confirmation prompts
(setq confirm-kill-emacs nil)                    ; Don't ask when exiting Emacs
(setq confirm-kill-processes nil)                ; Don't ask when killing processes
(setq kill-buffer-query-functions nil)          ; Don't ask when killing buffers
(setq large-file-warning-threshold nil)         ; Don't warn about large files
(setq vc-follow-symlinks t)                     ; Follow symlinks without asking
(setq enable-recursive-minibuffers t)           ; Allow recursive minibuffer commands

;; Disable "Buffer has a running process; kill it?" questions
(defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
  "Prevent annoying 'Active processes exist' query when you quit Emacs."
  (cl-letf (((symbol-function #'process-list) (lambda ())))
    ad-do-it))

;; Disable "Buffer modified; kill anyway?" questions
(defun my-kill-buffer-query-function ()
  "Don't ask questions when killing modified buffers."
  t)

(setq kill-buffer-query-functions '(my-kill-buffer-query-function))

;; Fast buffer killing without questions
(global-set-key (kbd "C-x k") 'kill-this-buffer)  ; Kill current buffer immediately

;; Quick copy entire buffer with Ctrl+Backspace
(defun copy-entire-buffer ()
  "Copy the entire buffer to clipboard without moving cursor or changing selection."
  (interactive)
  (let ((current-pos (point)))
    (save-excursion
      (kill-ring-save (point-min) (point-max)))
    (goto-char current-pos)
    (deactivate-mark)
    (message "Entire buffer copied to clipboard")))

(global-set-key (kbd "C-<backspace>") 'copy-entire-buffer)  ; Ctrl+Backspace

;; Smart DWIM commenting
(defun my-comment-dwim ()
  "Smart comment/uncomment that works on lines or regions."
  (interactive)
  (cond
   ;; If region is active, comment/uncomment the region
   ((use-region-p)
    (comment-or-uncomment-region (region-beginning) (region-end)))
   ;; If line is already commented, uncomment it
   ((save-excursion
      (beginning-of-line)
      (looking-at "^[ \t]*//\\|^[ \t]*/\\*\\|^[ \t]*#"))
    (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
   ;; Otherwise, comment the current line
   (t
    (comment-or-uncomment-region (line-beginning-position) (line-end-position)))))

;; Global key binding for smart commenting
(global-set-key (kbd "M-;") 'my-comment-dwim)     ; Meta+; (standard comment key)
(global-set-key (kbd "C-/") 'my-comment-dwim)     ; Ctrl+/ (modern IDE style)
(global-set-key (kbd "C-c c") 'my-comment-dwim)   ; Ctrl+c c (backup)
#+END_SRC

** File Finding & Navigation
The most powerful file finding setup for maximum productivity.

#+BEGIN_SRC emacs-lisp
;; Vertico + Consult - Modern Telescope-like interface
(unless (package-installed-p 'vertico)
  (package-install 'vertico))

(unless (package-installed-p 'consult)
  (package-install 'consult))

(unless (package-installed-p 'marginalia)
  (package-install 'marginalia))

(unless (package-installed-p 'orderless)
  (package-install 'orderless))

(require 'vertico)
(require 'consult)
(require 'marginalia)
(require 'orderless)

;; Enable Vertico (like Telescope fuzzy finder)
(vertico-mode 1)

;; Enable rich annotations in the minibuffer
(marginalia-mode 1)

;; Use orderless completion style for fuzzy matching
(setq completion-styles '(orderless basic)
      completion-category-defaults nil
      completion-category-overrides '((file (styles partial-completion))))

;; Telescope-like key bindings (with fallbacks)
(if (fboundp 'consult-M-x)
    (global-set-key (kbd "M-x") 'consult-M-x)                ; Better M-x with preview
  (global-set-key (kbd "M-x") 'execute-extended-command))    ; Fallback to default M-x

(global-set-key (kbd "C-x C-f") 'find-file)                 ; Keep standard find-file

(if (fboundp 'consult-buffer)
    (global-set-key (kbd "C-x b") 'consult-buffer)          ; Buffer switch with preview
  (global-set-key (kbd "C-x b") 'switch-to-buffer))         ; Fallback to default

(if (fboundp 'consult-recent-file)
    (global-set-key (kbd "C-x C-r") 'consult-recent-file)   ; Recent files
  (global-set-key (kbd "C-x C-r") 'recentf-open-files))     ; Fallback to recentf

;; Everything search integration for Windows (blazing fast system-wide search)
(when (eq system-type 'windows-nt)
  ;; Everything search within current project
  (defun everything-search-files (query)
    "Search for files using Everything search engine within current project."
    (interactive "sProject search: ")
    (let* ((project-root (or (projectile-project-root) default-directory))
           (search-path (replace-regexp-in-string "/" "\\\\" project-root))
           (results (when (> (length query) 0)
                      (split-string
                       (shell-command-to-string
                        (format "C:\\Users\\chris\\es.exe -n 20 \"%s\" \"%s\"" search-path query))
                       "\n" t))))
      (if results
          (let ((choice (completing-read "Select file: " results)))
            (when choice
              (find-file choice)))
        (message "No results found for: %s in project %s" query project-root))))

  ;; Everything search with Telescope-like interface
  (defun telescope-everything ()
    "Everything search with Telescope-like interface."
    (interactive)
    (let* ((query (read-string "Everything search: "))
           (results (when (> (length query) 0)
                      (split-string
                       (shell-command-to-string (format "C:\\Users\\chris\\es.exe -n 50 \"%s\"" query))
                       "\n" t))))
      (if results
          (let ((choice (completing-read "Select file: " results)))
            (when choice
              (find-file choice)))
        (message "No results found for: %s" query))))

  ;; Text search using consult-grep (Telescope-like)
  (defun telescope-grep ()
    "Search text in current directory using consult-grep."
    (interactive)
    (consult-grep default-directory))

  ;; Ripgrep text search in project
  (defun ripgrep-search ()
    "Search text content using ripgrep in current project."
    (interactive)
    (let* ((query (read-string "Ripgrep search: "))
           (project-root (or (projectile-project-root) default-directory))
           (cmd (format "rg --line-number --no-heading --color=never --max-count=20 \"%s\" \"%s\"" query project-root)))
      (when (> (length query) 0)
        (message "Searching for '%s'..." query)
        (let ((results (split-string
                        (shell-command-to-string cmd)
                        "\n" t)))
          (if results
              (let ((choice (completing-read "Select match: " results)))
                (when choice
                  (let* ((parts (split-string choice ":"))
                         (file (car parts))
                         (line-num (string-to-number (cadr parts))))
                    (find-file file)
                    (goto-line line-num))))
            (message "No matches found for: %s" query))))))

  ;; Key bindings (Telescope-like interface)
  (global-set-key (kbd "C-c s") 'telescope-everything)      ; File search with Everything (like leader ff)
  (global-set-key (kbd "C-c S") 'telescope-grep)            ; Text search with grep
  (global-set-key (kbd "C-c e") 'everything-search-files)   ; Everything in project
  (global-set-key (kbd "C-c r") 'ripgrep-search)            ; Text search with ripgrep

  (message "Everything search configured for Windows"))
#+END_SRC

** File Management (Dired)
Enhanced file browser with modern features.

#+BEGIN_SRC emacs-lisp
;; Dired configuration for better file management
(require 'dired)

;; Force vertical splits for dired
(setq split-height-threshold nil)      ; Never split horizontally
(setq split-width-threshold 100)      ; Split vertically when window is wide enough

;; Dired improvements
(setq dired-listing-switches "-alh")   ; Human-readable sizes, show hidden files
(setq dired-dwim-target t)             ; Guess target directory for operations
(setq dired-recursive-copies 'always)  ; Always copy recursively
(setq dired-recursive-deletes 'always) ; Always delete recursively

;; Modern dired enhancements
(unless (package-installed-p 'dired-sidebar)
  (package-install 'dired-sidebar))

(unless (package-installed-p 'all-the-icons)
  (package-install 'all-the-icons))

(unless (package-installed-p 'all-the-icons-dired)
  (package-install 'all-the-icons-dired))

(require 'dired-sidebar)
(require 'all-the-icons)
(require 'all-the-icons-dired)

;; Fonts are already manually installed - skip automatic installation
(message "all-the-icons fonts are already installed manually")

;; Add icons to dired (like VS Code file explorer)
(add-hook 'dired-mode-hook 'all-the-icons-dired-mode)

;; Fallback for Windows if icons don't work
(when (eq system-type 'windows-nt)
  (setq all-the-icons-dired-monochrome nil))

;; Dired sidebar configuration (like VS Code sidebar)
(setq dired-sidebar-theme 'nerd)
(setq dired-sidebar-use-term-integration t)
(setq dired-sidebar-use-custom-font t)  ; Let sidebar use its font for icons

;; Built-in dired buffer reuse (replaces dired-single)
(setq dired-kill-when-opening-new-dired-buffer t)  ; Kill old dired buffers

;; Custom functions to reuse dired buffers
(defun my-dired-find-file ()
  "Open file or directory in same dired buffer."
  (interactive)
  (let ((file (dired-get-filename)))
    (if (file-directory-p file)
        (find-alternate-file file)  ; Reuse buffer for directories
      (find-file file))))          ; Open files normally

(defun my-dired-up-directory ()
  "Go to parent directory in same buffer."
  (interactive)
  (find-alternate-file ".."))

;; Key bindings for buffer reuse
(defun my-dired-buffer-reuse-init ()
  "Initialize dired buffer reuse keybindings."
  (define-key dired-mode-map [return] 'my-dired-find-file)
  (define-key dired-mode-map "^" 'my-dired-up-directory))

(add-hook 'dired-mode-hook 'my-dired-buffer-reuse-init)

;; Key bindings for enhanced dired
(global-set-key (kbd "C-x C-d") 'dired-sidebar-toggle-sidebar)  ; Toggle sidebar
(global-set-key (kbd "C-x d") 'dired)                           ; Standard dired

;; Dired customizations
(defun my-dired-mode-setup ()
  "Customize dired mode."
  (dired-hide-details-mode 1)           ; Start with details hidden
  (hl-line-mode 1)                      ; Highlight current line
  ;; Ensure dired uses the same font as the rest of Emacs
  (when (member "JetBrainsMono Nerd Font" (font-family-list))
    (setq buffer-face-mode-face '(:family "JetBrainsMono Nerd Font" :height 110))
    (buffer-face-mode 1)))

(add-hook 'dired-mode-hook 'my-dired-mode-setup)

;; Also fix font for all special buffers
(defun my-ensure-consistent-font ()
  "Ensure all buffers use the same font, except dired sidebar."
  (when (and (member "JetBrainsMono Nerd Font" (font-family-list))
             (not (minibufferp))
             (not (string-match-p "\\*dired-sidebar\\*" (buffer-name))))  ; Exclude sidebar
    (setq buffer-face-mode-face '(:family "JetBrainsMono Nerd Font" :height 110))
    (buffer-face-mode 1)))

;; Apply to ALL modes that might have font issues
(add-hook 'help-mode-hook 'my-ensure-consistent-font)
(add-hook 'compilation-mode-hook 'my-ensure-consistent-font)
(add-hook 'occur-mode-hook 'my-ensure-consistent-font)
(add-hook 'grep-mode-hook 'my-ensure-consistent-font)
(add-hook 'shell-mode-hook 'my-ensure-consistent-font)
(add-hook 'eshell-mode-hook 'my-ensure-consistent-font)
(add-hook 'term-mode-hook 'my-ensure-consistent-font)
(add-hook 'magit-mode-hook 'my-ensure-consistent-font)
(add-hook 'markdown-mode-hook 'my-ensure-consistent-font)
(add-hook 'text-mode-hook 'my-ensure-consistent-font)
(add-hook 'prog-mode-hook 'my-ensure-consistent-font)
(add-hook 'fundamental-mode-hook 'my-ensure-consistent-font)
(add-hook 'special-mode-hook 'my-ensure-consistent-font)
(add-hook 'minibuffer-setup-hook
          (lambda ()
            (when (member "JetBrainsMono Nerd Font" (font-family-list))
              (setq buffer-face-mode-face '(:family "JetBrainsMono Nerd Font" :height 110))
              (buffer-face-mode 1))))

;; Global font lock to prevent other packages from changing fonts
(defadvice set-face-font (around preserve-jetbrains-font activate)
  "Prevent other packages from changing our JetBrains Mono font."
  (unless (member face '(mode-line mode-line-inactive))
    (when (member "JetBrainsMono Nerd Font" (font-family-list))
      (setq ad-return-value nil)  ; Block the font change
      (message "Font change blocked to preserve JetBrains Mono"))))

;; Force font consistency after package loads
(add-hook 'after-init-hook
          (lambda ()
            (when (member "JetBrainsMono Nerd Font" (font-family-list))
              (set-face-attribute 'default nil :family "JetBrainsMono Nerd Font" :height 110)
              (set-face-attribute 'fixed-pitch nil :family "JetBrainsMono Nerd Font" :height 110)
              (set-face-attribute 'variable-pitch nil :family "JetBrainsMono Nerd Font" :height 110)
              (message "Font consistency enforced globally"))))

;; Fix font for daemon-created frames (Windows-specific fix)
(add-hook 'after-make-frame-functions
          (lambda (frame)
            (with-selected-frame frame
              ;; Force font detection refresh for new frames
              (when (display-graphic-p frame)
                (cond
                 ;; Try JetBrains Mono Nerd Font first
                 ((member "JetBrainsMono Nerd Font" (font-family-list))
                  (set-face-attribute 'default frame :family "JetBrainsMono Nerd Font" :height 110)
                  (set-face-attribute 'fixed-pitch frame :family "JetBrainsMono Nerd Font" :height 110)
                  (message "Applied JetBrains Mono to new frame"))
                 ;; Fallback to Cascadia Code
                 ((member "Cascadia Code" (font-family-list))
                  (set-face-attribute 'default frame :family "Cascadia Code" :height 110)
                  (message "Applied Cascadia Code to new frame"))
                 ;; Fallback to Consolas
                 ((member "Consolas" (font-family-list))
                  (set-face-attribute 'default frame :family "Consolas" :height 110)
                  (message "Applied Consolas to new frame"))
                 (t
                  (message "No preferred fonts found for new frame")))))))

;; Additional daemon font fix - run when client connects
(defun fix-daemon-font ()
  "Fix font issues in daemon mode."
  (interactive)
  (when (display-graphic-p)
    (cond
     ((member "JetBrainsMono Nerd Font" (font-family-list))
      (set-face-attribute 'default nil :family "JetBrainsMono Nerd Font" :height 110)
      (message "JetBrains Mono applied"))
     ((member "Cascadia Code" (font-family-list))
      (set-face-attribute 'default nil :family "Cascadia Code" :height 110)
      (message "Cascadia Code applied"))
     (t
      (message "Using system default font")))))

;; Key binding to manually fix font if needed
(global-set-key (kbd "C-c M-f") 'fix-daemon-font)

;; Quick file operations
(defun dired-open-file-external ()
  "Open file with external application."
  (interactive)
  (let ((file (dired-get-filename)))
    (call-process-shell-command (format "start \"\" \"%s\"" file))))

(define-key dired-mode-map (kbd "E") 'dired-open-file-external)

;; Better window splitting behavior for all buffers
(defun my-split-window-sensibly (&optional window)
  "Custom window splitting that prefers vertical splits."
  (let ((window (or window (selected-window))))
    (or (and (window-splittable-p window t)
             (split-window window nil 'right))
        (and (window-splittable-p window)
             (split-window window)))))

(setq split-window-preferred-function 'my-split-window-sensibly)
#+END_SRC

** Project Management
Project navigation and management tools.

#+BEGIN_SRC emacs-lisp
;; Projectile for project navigation and management
(unless (package-installed-p 'projectile)
  (package-install 'projectile))

(require 'projectile)
(projectile-mode +1)

;; Integrate Projectile with Consult for Telescope-like navigation
(unless (package-installed-p 'consult-projectile)
  (package-install 'consult-projectile))

(require 'consult-projectile)

;; Telescope-like key bindings for Projectile
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
(global-set-key (kbd "C-c p f") 'consult-projectile-find-file)     ; Find file in project (like Telescope)
(global-set-key (kbd "C-c p p") 'consult-projectile-switch-project) ; Switch project
(global-set-key (kbd "C-c p s g") 'consult-projectile-grep)        ; Search in project


;; Magit for Git integration
(unless (package-installed-p 'magit)
  (package-install 'magit))

;; Company for better autocompletion
(unless (package-installed-p 'company)
  (package-install 'company))

(require 'company)
(add-hook 'after-init-hook 'global-company-mode)
(setq company-idle-delay 0.2)
(setq company-minimum-prefix-length 1)

;; Which-key for discoverable keybindings
(unless (package-installed-p 'which-key)
  (package-install 'which-key))

(require 'which-key)
(which-key-mode)

;; Multiple cursors for efficient editing
(unless (package-installed-p 'multiple-cursors)
  (package-install 'multiple-cursors))

(require 'multiple-cursors)
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)

;; Rainbow brackets for better code structure visualization
(unless (package-installed-p 'rainbow-delimiters)
  (package-install 'rainbow-delimiters))

(require 'rainbow-delimiters)

;; Enable rainbow brackets in programming modes
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
(add-hook 'c-mode-hook 'rainbow-delimiters-mode)
(add-hook 'go-mode-hook 'rainbow-delimiters-mode)
(add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
(add-hook 'lisp-interaction-mode-hook 'rainbow-delimiters-mode)

;; Configure rainbow colors to match voidlight theme
(with-eval-after-load 'rainbow-delimiters
  (set-face-foreground 'rainbow-delimiters-depth-1-face "#569cd6")    ; Blue
  (set-face-foreground 'rainbow-delimiters-depth-2-face "#4ec9b0")    ; Cyan
  (set-face-foreground 'rainbow-delimiters-depth-3-face "#9cdcfe")    ; Light blue
  (set-face-foreground 'rainbow-delimiters-depth-4-face "#b5cea8")    ; Green
  (set-face-foreground 'rainbow-delimiters-depth-5-face "#ce9178")    ; Orange
  (set-face-foreground 'rainbow-delimiters-depth-6-face "#d4d4d4")    ; Light gray
  (set-face-foreground 'rainbow-delimiters-depth-7-face "#c586c0")    ; Purple
  (set-face-foreground 'rainbow-delimiters-depth-8-face "#dcdcaa")    ; Yellow
  (set-face-foreground 'rainbow-delimiters-depth-9-face "#f44747"))   ; Red
#+END_SRC

* Usage Notes
** Key Bindings
*** Build/Run/Debug
- =F3= - Build Dream project
- =F4= - Run Dream project
- =Shift+F4= - Debug Dream project in RemedyBG

*** File Finding & Navigation (Helm-powered)
- =C-x C-f= - Find files (Helm fuzzy matching)
- =C-x b= - Switch buffers (with recent files)
- =C-x C-r= - Recent files
- =M-x= - Enhanced command palette
- =C-c p f= - Find file in project (fuzzy)
- =C-c p p= - Switch between projects
- =C-c e= - Everything search (system-wide on Windows)

*** Text Search
- =C-c s= - File search with Everything (system-wide)
- =C-c S= - Text search in current directory (grep)
- =C-c p s g= - Search text in project (Helm + grep)

*** LSP Navigation
- =M-x eglot= - Start LSP server for current C file (auto-starts)
- =M-.= - Go to definition (when LSP is active)
- =M-,= - Go back from definition

*** Git Integration
- =C-x g= - Magit status (staging, commits, push/pull)

*** Multiple Cursors
- =C-S-c C-S-c= - Edit multiple lines
- =C->= - Mark next like this
- =C-<= - Mark previous like this
- =C-c C-<= - Mark all like this

** LSP Features
When Eglot is active in a C file, you get:
- Code completion
- Go to definition/declaration
- Find references
- Real-time diagnostics
- Hover documentation

** Build Integration
The F3 build command will:
- Switch to the Dream project directory
- Run CMake build with Release configuration
- Show build output in a compilation buffer
- Allow clicking on errors to jump to source locations