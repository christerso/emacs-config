#+TITLE: Clean Modular Emacs Configuration
#+AUTHOR: Chris
#+DESCRIPTION: Minimal config that loads tested modules only
#+STARTUP: overview

* Basic Setup
#+BEGIN_SRC emacs-lisp
;; Basic settings
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)
(menu-bar-mode -1)
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(global-display-line-numbers-mode 1)

;; No prompts
(setq confirm-kill-emacs nil)
(setq kill-buffer-query-functions nil)

;; Never ask about killing modified buffers
(setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function
            kill-buffer-query-functions))
(global-set-key (kbd "C-x k")
                (lambda ()
                  (interactive)
                  (kill-buffer (current-buffer))))

;; Persistent scratch buffer
(setq initial-major-mode 'lisp-interaction-mode)
(setq initial-buffer-choice
      (lambda ()
        (let ((scratch-file (expand-file-name "scratch.el" user-emacs-directory)))
          (if (file-exists-p scratch-file)
              (progn
                (find-file-noselect scratch-file)
                (set-buffer-major-mode (get-file-buffer scratch-file) 'lisp-interaction-mode))
            (get-buffer-create "*scratch*")))))

(defun save-scratch ()
  "Save scratch buffer to persistent file."
  (interactive)
  (let ((scratch-file (expand-file-name "scratch.el" user-emacs-directory))
        (scratch-buffer (get-buffer "*scratch*")))
    (when scratch-buffer
      (with-current-buffer scratch-buffer
        (write-region (point-min) (point-max) scratch-file)
        (message "Scratch buffer saved to %s" scratch-file)))))

(defun load-scratch ()
  "Load scratch buffer from persistent file."
  (interactive)
  (let ((scratch-file (expand-file-name "scratch.el" user-emacs-directory)))
    (if (file-exists-p scratch-file)
        (with-current-buffer (get-buffer-create "*scratch*")
          (erase-buffer)
          (insert-file-contents scratch-file)
          (lisp-interaction-mode)
          (message "Scratch buffer loaded from %s" scratch-file))
      (message "No saved scratch buffer found"))))

;; Auto-save scratch on exit
(add-hook 'kill-emacs-hook 'save-scratch)

;; Load scratch on startup
(add-hook 'emacs-startup-hook 'load-scratch)

;; Essential keys
(global-set-key (kbd "C-c d") 'save-scratch)
(global-set-key (kbd "C-x C-r") 'recentf-open-files)

(recentf-mode 1)
(setq recentf-max-saved-items 100)
(setq recentf-auto-cleanup 'never)
(unless recentf-list
  (recentf-load-list))

;; LSP and completion will be handled by modules only

;; F3 key binding will be handled by project-builds module
#+END_SRC

* Package Management
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives
      '(("gnu" . "https://elpa.gnu.org/packages/")
        ("nongnu" . "https://elpa.nongnu.org/nongnu/")
        ("melpa" . "https://melpa.org/packages/")))
(setq package-check-signature nil)
(package-initialize)
(when (not package-archive-contents)
  (package-refresh-contents))
#+END_SRC

* Module System
#+BEGIN_SRC emacs-lisp
;; Create modules directory if it doesn't exist
(let ((modules-dir (expand-file-name "modules" user-emacs-directory)))
  (unless (file-directory-p modules-dir)
    (make-directory modules-dir t)))

;; Load ALL essential modules safely
(dolist (module '("core-packages"     ; Vertico, Consult, Company
                  "theme-system"       ; Dark theme and colors
                  "font-system"        ; Font enforcement
                  "xref-preview"       ; Interactive xref navigation
                  "c-cpp-support"      ; C and C++ development
                  "odin-support"       ; Odin language support
                  "language-support"   ; Additional language support
                  "file-management"    ; Treemacs, Everything search
                  "window-navigation"  ; Window movement
                  "workspace-management" ; Project workspaces
                  "windows-unicode-fix" ; Unicode support
                  "auto-focus"         ; Auto focus behavior
                  "odin-unicode"       ; Odin-specific Unicode fixes
                  "project-builds"))   ; F3/F4 smart project build system
  (let ((module-file (expand-file-name (concat "modules/" module ".org") user-emacs-directory)))
    (when (file-exists-p module-file)
      (condition-case err
          (progn
            ;; Ensure we're in the right directory for org-babel
            (let ((default-directory user-emacs-directory))
              (org-babel-load-file module-file))
            (message "âœ“ LOADED: %s" module))
        (error
         (message "âœ— FAILED: %s - %s" module (error-message-string err)))))))

;; Enhanced error reporting for failed modules
  (run-with-timer 2.0 nil
                  (lambda ()
                    (let ((loaded-modules 0)
                          (failed-modules '())
                          (messages (with-current-buffer "*Messages*"
                                       (buffer-string))))

                      ;; Parse the messages buffer to find loaded and failed modules
                      (with-temp-buffer
                        (insert messages)
                        (goto-char (point-min))
                        (while (re-search-forward "^âœ“ LOADED: \\(.+\\)$" nil t)
                          (setq loaded-modules (1+ loaded-modules)))
                        (goto-char (point-min))
                        (while (re-search-forward "^âœ— FAILED: \\(.+\\) - \\(.+\\)$" nil t)
                          (push (list (match-string 1) (match-string 2)) failed-modules)))

                      ;; Display comprehensive report
                      (message "=== MODULE LOADING REPORT ===")
                      (message "âœ“ Successfully loaded: %d modules" loaded-modules)
                      (message "âœ— Failed to load: %d modules" (length failed-modules))

                      ;; Show failed modules prominently
                      (when failed-modules
                        (dolist (failure failed-modules)
                          (message "ðŸš¨ FAILED: %s (%s)" (car failure) (cadr failure)))

                        ;; Create dedicated failed modules buffer for high visibility
                        (with-current-buffer (get-buffer-create "*FAILED MODULES*")
                          (setq buffer-read-only nil)
                          (erase-buffer)
                          (insert "!!! FAILED EMACS MODULES !!!\n")
                          (insert "==============================\n\n")
                          (insert (format "Total modules loaded: %d\n" loaded-modules))
                          (insert (format "Failed modules: %d\n\n" (length failed-modules)))
                          (insert "FAILED MODULES:\n")
                          (insert "----------------\n")
                          (dolist (failure failed-modules)
                            (insert (format "ðŸš¨ %s\n   Error: %s\n\n" (car failure) (cadr failure))))
                          (insert "\nPlease check these modules and fix any issues.\n")
                          (setq buffer-read-only t))

                        ;; Display the failed modules buffer
                        (display-buffer "*FAILED MODULES*")
                        (message "ðŸš¨ FAILED MODULES DETECTED - See *FAILED MODULES* buffer"))

                      (unless failed-modules
                        (message "âœ“ ALL MODULES LOADED SUCCESSFULLY")))))
#+END_SRC