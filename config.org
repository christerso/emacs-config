#+TITLE: Emacs Configuration for C11 Development
#+AUTHOR: Chris
#+DESCRIPTION: Literate Emacs configuration using org-mode for C11 development with LSP
#+STARTUP: overview

* Introduction
This is a literate Emacs configuration written in org-mode for C11 development.
The configuration includes LSP support via Eglot, quick build commands, and a clean setup.

* Basic Settings
** Startup and UI
Clean up the default Emacs interface for a minimal development environment.

#+BEGIN_SRC emacs-lisp
;; Basic settings
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)

;; Replace default scratch buffer with interactive dashboard
(setq initial-major-mode 'org-mode)            ; Start in org-mode
(setq initial-buffer-choice                    ; Use dashboard as startup buffer
      (lambda ()
        (let ((dashboard-file (expand-file-name "dashboard.org" user-emacs-directory)))
          (if (file-exists-p dashboard-file)
              (find-file-noselect dashboard-file)
            (get-buffer-create "*Dashboard*")))))

;; Session persistence - remember everything automatically
(desktop-save-mode 1)                          ; Save/restore buffers and window config
(setq desktop-restore-eager 5)                 ; Restore first 5 buffers immediately
(setq desktop-lazy-verbose nil)                ; Don't show messages for lazy loading
(setq desktop-save t)                          ; Always save session
(setq desktop-load-locked-desktop t)           ; Load even if locked

;; Remember recent files
(recentf-mode 1)
(setq recentf-max-saved-items 100)             ; Remember 100 recent files
(setq recentf-auto-cleanup 'never)             ; Don't cleanup automatically

;; Remember minibuffer history
(savehist-mode 1)
(setq savehist-additional-variables            ; Save additional useful variables
      '(search-ring regexp-search-ring))

;; Remember cursor position in files
(save-place-mode 1)

;; Persistent org-mode scratch buffer
(defun save-persistent-scratch ()
  "Save the org scratch buffer to disk only if it has been modified."
  (when (get-buffer "*scratch*")
    (with-current-buffer "*scratch*"
      (when (buffer-modified-p)
        (write-region (point-min) (point-max)
                      (expand-file-name "scratch.org" user-emacs-directory))
        (set-buffer-modified-p nil)  ; Mark as unmodified after saving
        (message "Scratch buffer saved")))))

(defun load-persistent-scratch ()
  "Load the persistent org scratch buffer from disk."
  (let ((scratch-file (expand-file-name "scratch.org" user-emacs-directory)))
    (with-current-buffer "*scratch*"
      (erase-buffer)
      (if (file-exists-p scratch-file)
          (insert-file-contents scratch-file)
        ;; Create initial org-mode scratch content
        (insert "#+TITLE: Scratch Notes\n")
        (insert "#+AUTHOR: Chris\n")
        (insert "#+DATE: " (format-time-string "%Y-%m-%d") "\n\n")
        (insert "* Quick Notes\n\n")
        (insert "* Code Experiments\n\n")
        (insert "#+BEGIN_SRC emacs-lisp\n")
        (insert ";; Evaluate with C-c C-c\n")
        (insert "(+ 1 2 3)\n")
        (insert "#+END_SRC\n\n")
        (insert "* TODO Items\n")
        (insert "- [ ] Task 1\n")
        (insert "- [ ] Task 2\n\n"))
      (org-mode)
      (goto-char (point-min)))))

;; Auto-save org scratch buffer periodically
(run-with-idle-timer 30 t 'save-persistent-scratch)  ; Save every 30 seconds when idle

;; Initialize org-mode scratch on startup
(add-hook 'after-init-hook
          (lambda ()
            ;; Kill default scratch if it exists
            (when (get-buffer "*scratch*")
              (with-current-buffer "*scratch*"
                (when (eq major-mode 'lisp-interaction-mode)
                  (erase-buffer))))
            ;; Load our persistent org scratch
            (load-persistent-scratch)))

;; Save scratch on exit
(add-hook 'kill-emacs-hook 'save-persistent-scratch)

;; Create org scratch buffer function
(defun create-scratch-buffer ()
  "Create or switch to persistent org-mode scratch buffer."
  (interactive)
  (switch-to-buffer "*scratch*")
  (unless (eq major-mode 'org-mode)
    (org-mode)))

;; Dashboard functions
(defun open-dashboard ()
  "Open the Emacs dashboard."
  (interactive)
  (let ((dashboard-file (expand-file-name "dashboard.org" user-emacs-directory)))
    (if (file-exists-p dashboard-file)
        (find-file dashboard-file)
      (message "Dashboard file not found: %s" dashboard-file))))

;; Key bindings for dashboard and scratch
(global-set-key (kbd "C-c d") 'open-dashboard)      ; Quick access to dashboard
(global-set-key (kbd "C-c C-d") 'open-dashboard)    ; Alternative dashboard access
(global-set-key (kbd "C-c s c") 'create-scratch-buffer)

;; Basic UI cleanup
(menu-bar-mode -1)
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

;; Show line numbers
(global-display-line-numbers-mode 1)

;; Disable annoying audible bell
(setq ring-bell-function 'ignore)              ; Completely disable bell
(setq visible-bell nil)                        ; No visual bell either (clean)
#+END_SRC

** File Management
Prevent Emacs from creating clutter files like backups and auto-saves.

#+BEGIN_SRC emacs-lisp
;; Backup and auto-save settings - no clutter files
(setq make-backup-files nil)            ; No backup files (file~)
(setq auto-save-default nil)            ; No auto-save files (#file#)
(setq create-lockfiles nil)             ; No lock files (.#file)
#+END_SRC

** Editing Defaults
Basic editing preferences for consistent code style.

#+BEGIN_SRC emacs-lisp
;; Basic editing
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)

;; IMMEDIATE KEYBINDING FIXES - Essential navigation
;; Recent files
(global-set-key (kbd "C-x C-r") 'recentf-open-files)

;; Enhanced buffer switching (fallback to default if consult not available)
(global-set-key (kbd "C-x b") 'switch-to-buffer)
#+END_SRC

* Package Management
** Repository Setup
Configure package repositories and disable signature verification for Windows compatibility.

#+BEGIN_SRC emacs-lisp
;; Package management
(require 'package)
(setq package-archives
      '(("gnu" . "https://elpa.gnu.org/packages/")
        ("nongnu" . "https://elpa.nongnu.org/nongnu/")
        ("melpa" . "https://melpa.org/packages/")
        ("melpa-stable" . "https://stable.melpa.org/packages/")))

;; Disable package signature verification to avoid GPG issues
(setq package-check-signature nil)

(package-initialize)

;; Refresh package contents only if needed (to speed up startup)
(when (not package-archive-contents)
  (package-refresh-contents))
#+END_SRC

** Theme Installation
Install and configure the voidlight theme for comfortable dark coding.

#+BEGIN_SRC emacs-lisp
;; Download and install voidlight theme manually from GitHub
(let ((theme-dir (expand-file-name "themes" user-emacs-directory))
      (theme-file (expand-file-name "themes/voidlight-theme.el" user-emacs-directory)))

  ;; Create themes directory if it doesn't exist
  (unless (file-directory-p theme-dir)
    (make-directory theme-dir t))

  ;; Download theme file if it doesn't exist
  (unless (file-exists-p theme-file)
    (url-copy-file "https://raw.githubusercontent.com/christerso/emacs-voidlight-theme/main/voidlight-theme.el"
                   theme-file t))

  ;; Add themes directory to custom theme load path
  (add-to-list 'custom-theme-load-path theme-dir)

  ;; Load the voidlight theme
  (load-theme 'voidlight t)

  ;; Customize selection/region color - darker background only
  (set-face-background 'region "#1e2124")        ; Much darker gray selection

  ;; Also make secondary selection darker
  (set-face-background 'secondary-selection "#151618"))
#+END_SRC

** Claude Code Integration
Install and configure claude-code.el for enhanced AI integration.

#+BEGIN_SRC emacs-lisp
;; Download and install claude-code.el from GitHub
(let ((claude-code-dir (expand-file-name "claude-code" user-emacs-directory))
      (claude-code-file (expand-file-name "claude-code/claude-code.el" user-emacs-directory)))

  ;; Create claude-code directory if it doesn't exist
  (unless (file-directory-p claude-code-dir)
    (make-directory claude-code-dir t))

  ;; Download claude-code.el if it doesn't exist
  (unless (file-exists-p claude-code-file)
    (message "Downloading claude-code.el from GitHub...")
    (url-copy-file "https://raw.githubusercontent.com/stevemolitor/claude-code.el/main/claude-code.el"
                   claude-code-file t))

  ;; Add claude-code directory to load path
  (add-to-list 'load-path claude-code-dir)

  ;; Load claude-code if available
  (when (file-exists-p claude-code-file)
    (condition-case err
        (progn
          (require 'claude-code)

          ;; Configure claude-code for Windows compatibility
          (when (eq system-type 'windows-nt)
            ;; Add Windows-specific configuration after claude-code loads
            (with-eval-after-load 'claude-code
              ;; Set up alternative backends if eat fails
              (when (boundp 'claude-code-terminal-backend)
                (message "Configuring claude-code terminal backend..."))))

          (message "claude-code.el loaded successfully"))
      (error
       (message "Error loading claude-code.el: %s" (error-message-string err))))))
#+END_SRC

** Font Configuration
Configure a beautiful Nerd Font for optimal programming experience with icons and ligatures.

#+BEGIN_SRC emacs-lisp
;; Font customization function - stand on a font and open customize options
(defun customize-font-at-point ()
  "Open customize options for the font at point."
  (interactive)
  (let* ((face-prop (get-char-property (point) 'face))
         (face-name (cond
                     ;; Handle list of faces
                     ((listp face-prop) (car face-prop))
                     ;; Handle single face
                     ((symbolp face-prop) face-prop)
                     ;; Handle face attributes (like :foreground)
                     ((keywordp face-prop) 'default)
                     ;; Fallback to face-at-point
                     (t (face-at-point t)))))
    ;; Ensure we have a valid face symbol
    (when (or (not face-name) (keywordp face-name) (not (symbolp face-name)))
      (setq face-name 'default))
    (message "Customizing font for face: %s" face-name)
    (customize-face face-name)))

;; Key binding for font customization at point
(global-set-key (kbd "C-c C-f") 'customize-font-at-point)

;; AGGRESSIVE JETBRAINS FONT ENFORCEMENT
;; This ensures JetBrains Mono Nerd Font is used everywhere without exception

(defvar my-protected-face-patterns
  '("icon" "treemacs" "all-the-icons" "nerd-icons" "dired-directory"
    "magit-diff" "git-gutter" "flycheck" "company-tooltip" "lsp-ui"
    "rainbow-delimiters" "hl-line" "region" "isearch" "lazy-highlight"
    "show-paren" "cursor" "fringe" "vertical-border")
  "Face name patterns that should not be modified by font enforcement.
These faces often contain special symbols, icons, or UI elements.")

(defun my-face-should-be-protected-p (face-name)
  "Return t if FACE-NAME should be protected from font changes."
  (let ((face-str (symbol-name face-name)))
    (cl-some (lambda (pattern)
               (string-match-p pattern face-str))
             my-protected-face-patterns)))

(defun force-jetbrains-font-selectively ()
  "Enforce JetBrains Mono font only on text faces, preserving special symbols."
  (when (member "JetBrainsMono Nerd Font" (font-family-list))
    ;; Core text faces - always safe to change
    (set-face-attribute 'default nil :family "JetBrainsMono Nerd Font" :height 110)
    (set-face-attribute 'fixed-pitch nil :family "JetBrainsMono Nerd Font" :height 110)
    (set-face-attribute 'variable-pitch nil :family "JetBrainsMono Nerd Font" :height 110)

    ;; Mode line (safe for text content)
    (set-face-attribute 'mode-line nil :family "JetBrainsMono Nerd Font" :height 100)
    (set-face-attribute 'mode-line-inactive nil :family "JetBrainsMono Nerd Font" :height 100)
    (set-face-attribute 'header-line nil :family "JetBrainsMono Nerd Font" :height 110)
    (set-face-attribute 'minibuffer-prompt nil :family "JetBrainsMono Nerd Font" :height 110)

    ;; Programming language faces (safe - just text styling)
    (dolist (face '(font-lock-comment-face font-lock-string-face font-lock-keyword-face
                    font-lock-function-name-face font-lock-variable-name-face
                    font-lock-type-face font-lock-constant-face font-lock-builtin-face
                    font-lock-preprocessor-face font-lock-doc-face))
      (when (facep face)
        (set-face-attribute face nil :family "JetBrainsMono Nerd Font")))

    ;; Odin-specific faces (if they exist)
    (dolist (face '(odin-font-lock-keyword-face odin-font-lock-type-face
                    odin-font-lock-builtin-face odin-font-lock-constant-face))
      (when (facep face)
        (set-face-attribute face nil :family "JetBrainsMono Nerd Font")))

    ;; Text mode faces (safe)
    (dolist (face '(org-block org-code org-verbatim markdown-code-face
                    markdown-inline-code-face markdown-pre-face))
      (when (and (facep face) (not (my-face-should-be-protected-p face)))
        (set-face-attribute face nil :family "JetBrainsMono Nerd Font")))

    ;; Compilation faces (safe - just text)
    (dolist (face '(compilation-info compilation-error compilation-warning
                    compilation-line-number compilation-column-number))
      (when (facep face)
        (set-face-attribute face nil :family "JetBrainsMono Nerd Font")))

    ;; Help faces (safe - documentation text)
    (dolist (face '(help-key-binding help-argument-name))
      (when (facep face)
        (set-face-attribute face nil :family "JetBrainsMono Nerd Font")))

    ;; Only safe dired faces (avoid file icons)
    (when (facep 'dired-header)
      (set-face-attribute 'dired-header nil :family "JetBrainsMono Nerd Font"))

    ;; Terminal faces (safe - just text)
    (dolist (face '(term ansi-term))
      (when (facep face)
        (set-face-attribute face nil :family "JetBrainsMono Nerd Font")))

    ;; Completion text (but avoid tooltip styling)
    (when (and (facep 'completions-common-part)
               (not (my-face-should-be-protected-p 'completions-common-part)))
      (set-face-attribute 'completions-common-part nil :family "JetBrainsMono Nerd Font"))

    (message "JetBrains Mono font applied selectively (preserving app-specific fonts)")))

;; Apply selective font enforcement immediately and after package loads
(force-jetbrains-font-selectively)

;; Selective font protection - re-enforce after any package loads
(add-hook 'after-load-functions
          (lambda (feature)
            (force-jetbrains-font-selectively)))

;; Re-enforce fonts after theme loads
(add-hook 'after-init-hook 'force-jetbrains-font-selectively)

;; Periodic font enforcement (less aggressive)
(run-with-idle-timer 10 t 'force-jetbrains-font-selectively)

;; Set default font to JetBrains Mono Nerd Font with Unicode support
(when (member "JetBrainsMono Nerd Font" (font-family-list))
  (set-face-attribute 'default nil :family "JetBrainsMono Nerd Font" :height 110)
  (set-face-attribute 'fixed-pitch nil :family "JetBrainsMono Nerd Font" :height 110)

  ;; COMPREHENSIVE UNICODE AND FONT SYSTEM
  ;; This ensures perfect rendering of all characters and symbols

  ;; Enable UTF-8 everywhere first
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-file-name-coding-system 'utf-8)
  (set-clipboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)

  ;; Force Unicode display optimizations
  (setq inhibit-compacting-font-caches t)      ; Never compact font caches
  (setq use-default-font-for-symbols nil)      ; Always use fontset for symbols
  (setq w32-enable-unicode-output t)           ; Enable Unicode output on Windows
  (setq bidi-paragraph-direction 'left-to-right) ; Optimize for LTR text

  ;; Primary font: JetBrains Mono Nerd Font for everything possible
  (set-fontset-font t 'unicode "JetBrainsMono Nerd Font" nil 'prepend)

  ;; Unicode ranges with perfect fallback chain
  ;; Basic Latin and extensions - JetBrains first
  (set-fontset-font t '(#x0000 . #x024F) "JetBrainsMono Nerd Font" nil 'prepend)
  (set-fontset-font t '(#x0000 . #x024F) "Cascadia Code" nil 'append)
  (set-fontset-font t '(#x0000 . #x024F) "Consolas" nil 'append)

  ;; Mathematical symbols and operators
  (set-fontset-font t '(#x2190 . #x21FF) "JetBrainsMono Nerd Font" nil 'prepend) ; Arrows
  (set-fontset-font t '(#x2200 . #x22FF) "JetBrainsMono Nerd Font" nil 'prepend) ; Math operators
  (set-fontset-font t '(#x2300 . #x23FF) "JetBrainsMono Nerd Font" nil 'prepend) ; Technical symbols
  (set-fontset-font t '(#x25A0 . #x25FF) "JetBrainsMono Nerd Font" nil 'prepend) ; Geometric shapes

  ;; Programming and technical symbols
  (set-fontset-font t '(#xE000 . #xF8FF) "JetBrainsMono Nerd Font" nil 'prepend) ; Private use (Nerd Font icons)
  (set-fontset-font t '(#xF0000 . #xFFFFF) "JetBrainsMono Nerd Font" nil 'prepend) ; More private use

  ;; Fallback for symbols JetBrains doesn't have
  (set-fontset-font t '(#x2000 . #x2FFF) "Segoe UI Symbol" nil 'append)  ; General punctuation & symbols
  (set-fontset-font t '(#x2600 . #x26FF) "Segoe UI Symbol" nil 'append)  ; Miscellaneous symbols
  (set-fontset-font t '(#x2700 . #x27BF) "Segoe UI Symbol" nil 'append)  ; Dingbats
  (set-fontset-font t '(#x2B00 . #x2BFF) "Segoe UI Symbol" nil 'append)  ; Misc symbols and arrows

  ;; Emoji support (high priority)
  (set-fontset-font t '(#x1F000 . #x1FFFF) "Segoe UI Emoji" nil 'append) ; All emoji blocks
  (set-fontset-font t '(#x1F300 . #x1F5FF) "Segoe UI Emoji" nil 'append) ; Misc symbols and pictographs
  (set-fontset-font t '(#x1F600 . #x1F64F) "Segoe UI Emoji" nil 'append) ; Emoticons
  (set-fontset-font t '(#x1F680 . #x1F6FF) "Segoe UI Emoji" nil 'append) ; Transport and map
  (set-fontset-font t '(#x1F700 . #x1F77F) "Segoe UI Emoji" nil 'append) ; Alchemical
  (set-fontset-font t '(#x1F780 . #x1F7FF) "Segoe UI Emoji" nil 'append) ; Geometric shapes ext
  (set-fontset-font t '(#x1F800 . #x1F8FF) "Segoe UI Emoji" nil 'append) ; Supplemental arrows
  (set-fontset-font t '(#x1F900 . #x1F9FF) "Segoe UI Emoji" nil 'append) ; Supplemental symbols

  ;; Critical symbols that must work
  (set-fontset-font t ?✓ "Segoe UI Symbol" nil 'append)  ; Checkmark
  (set-fontset-font t ?✅ "Segoe UI Emoji" nil 'append)   ; Check mark button
  (set-fontset-font t ?❌ "Segoe UI Emoji" nil 'append)   ; Cross mark
  (set-fontset-font t ?⚠ "Segoe UI Symbol" nil 'append)   ; Warning sign
  (set-fontset-font t ?→ "JetBrainsMono Nerd Font" nil 'prepend) ; Right arrow
  (set-fontset-font t ?← "JetBrainsMono Nerd Font" nil 'prepend) ; Left arrow
  (set-fontset-font t ?↑ "JetBrainsMono Nerd Font" nil 'prepend) ; Up arrow
  (set-fontset-font t ?↓ "JetBrainsMono Nerd Font" nil 'prepend) ; Down arrow
  (set-fontset-font t ?• "JetBrainsMono Nerd Font" nil 'prepend) ; Bullet
  (set-fontset-font t ?◦ "JetBrainsMono Nerd Font" nil 'prepend) ; White bullet

  ;; Final safety net for anything we missed
  (set-fontset-font t 'unicode "Symbola" nil 'append)     ; Comprehensive symbol font
  (set-fontset-font t 'unicode "DejaVu Sans" nil 'append) ; General fallback
  (set-fontset-font t 'unicode "Arial Unicode MS" nil 'append) ; Windows Unicode fallback

  ;; International character support
  (set-fontset-font t 'latin "JetBrainsMono Nerd Font" nil 'prepend)
  (set-fontset-font t 'greek "JetBrainsMono Nerd Font" nil 'prepend)
  (set-fontset-font t 'cyrillic "JetBrainsMono Nerd Font" nil 'prepend))

;; Fallback fonts if JetBrains Mono Nerd Font is not available
(unless (member "JetBrainsMono Nerd Font" (font-family-list))
  (cond
   ;; Try Cascadia Code (Windows 11 default, has ligatures)
   ((member "Cascadia Code" (font-family-list))
    (set-face-attribute 'default nil :family "Cascadia Code" :height 110))
   ;; Try Fira Code (popular programming font)
   ((member "Fira Code" (font-family-list))
    (set-face-attribute 'default nil :family "Fira Code" :height 110))
   ;; Fallback to Consolas (Windows default monospace)
   ((member "Consolas" (font-family-list))
    (set-face-attribute 'default nil :family "Consolas" :height 110))))
#+END_SRC

* Development Environment
** Windows PATH Configuration
Set up the Windows environment to find clangd and other development tools.

#+BEGIN_SRC emacs-lisp
;; PATH setup for Windows
(when (eq system-type 'windows-nt)
  (setenv "PATH" (concat "C:\\Program Files\\LLVM\\bin;"
                         "C:\\Users\\chris\\go\\bin;"
                         "G:\\repos\\Odin;"
                         (getenv "PATH")))
  (setq exec-path (append '("C:\\Program Files\\LLVM\\bin"
                           "C:\\Users\\chris\\go\\bin"
                           "G:\\repos\\Odin")
                         exec-path)))
#+END_SRC

** LSP Configuration with Eglot
Configure Eglot (built-in LSP client) for C development with clangd.
Automatically starts when opening C files.

#+BEGIN_SRC emacs-lisp
;; Eglot LSP setup
(require 'eglot)

;; Configure clangd for C files
(add-to-list 'eglot-server-programs '(c-mode . ("clangd")))

;; Automatically start Eglot for C files
(add-hook 'c-mode-hook 'eglot-ensure)

;; Disable problematic flymake backends completely (we use Eglot for diagnostics)
(with-eval-after-load 'flymake
  (setq flymake-cc-command nil)                           ; Disable flymake-cc command
  (remove-hook 'flymake-diagnostic-functions 'flymake-cc) ; Remove from functions
  (when (fboundp 'flymake-cc)
    (fmakunbound 'flymake-cc)))                           ; Remove function entirely

;; Also disable flymake completely in C mode since we use Eglot
(add-hook 'c-mode-hook
          (lambda ()
            (flymake-mode -1)))  ; Disable flymake, use Eglot diagnostics instead

;; Automatic file headers
(defun insert-c-header ()
  "Insert standard C file header for new files."
  (when (and (buffer-file-name)
             (= (point-min) (point-max))  ; Empty file
             (string-match-p "\\.\\(c\\|h\\)$" (buffer-file-name)))
    (let ((filename (file-name-nondirectory (buffer-file-name)))
          (is-header (string-match-p "\\.h$" (buffer-file-name))))
      (insert (format "/**\n"))
      (insert (format " * @file %s\n" filename))
      (insert (format " * @brief \n"))
      (insert (format " * @author Christer Söderlund <christer.soderlund@gmail.com>\n"))
      (insert (format " * @date %s\n" (format-time-string "%Y-%m-%d")))
      (insert (format " * @copyright Copyright (c) %s Christer Söderlund\n" (format-time-string "%Y")))
      (insert (format " */\n\n"))

      (when is-header
        (let ((guard-name (upcase (replace-regexp-in-string "[^a-zA-Z0-9]" "_"
                                                           (file-name-sans-extension filename)))))
          (insert (format "#ifndef %s_H\n" guard-name))
          (insert (format "#define %s_H\n\n" guard-name))
          (insert "#ifdef __cplusplus\n")
          (insert "extern \"C\" {\n")
          (insert "#endif\n\n")
          (insert "// Header content here\n\n")
          (insert "#ifdef __cplusplus\n")
          (insert "}\n")
          (insert "#endif\n\n")
          (insert (format "#endif // %s_H\n" guard-name))))

      (goto-char (point-min))
      (search-forward "@brief ")
      (message "C header inserted - fill in @brief description"))))

(defun insert-go-header ()
  "Insert standard Go file header for new files."
  (when (and (buffer-file-name)
             (= (point-min) (point-max))  ; Empty file
             (string-match-p "\\.go$" (buffer-file-name)))
    (let ((filename (file-name-nondirectory (buffer-file-name)))
          (package-name (file-name-nondirectory (directory-file-name default-directory))))
      (insert (format "// Package %s \n" package-name))
      (insert (format "// File: %s\n" filename))
      (insert (format "// Author: Christer Söderlund <christer.soderlund@gmail.com>\n"))
      (insert (format "// Date: %s\n" (format-time-string "%Y-%m-%d")))
      (insert (format "// Copyright (c) %s Christer Söderlund\n\n" (format-time-string "%Y")))
      (insert (format "package %s\n\n" package-name))
      (goto-char (point-min))
      (search-forward "Package ")
      (message "Go header inserted - fill in package description"))))
#+END_SRC

** C Language Settings
Configure C-specific editing preferences and style.

#+BEGIN_SRC emacs-lisp
;; C-specific settings
(add-hook 'c-mode-hook
          (lambda ()
            (setq c-default-style "k&r")
            (setq c-basic-offset 2)    ; Use 2 spaces for C (more standard)
            ;; Insert header for new files
            (insert-c-header)
            ;; Auto-format C files when opened (after brief delay)
            (run-with-idle-timer 0.5 nil 'format-buffer)))  ; Format after 0.5s delay

;; Autoformatting with clang-format
(defun format-buffer ()
  "Format the current buffer using clang-format with C-specific style."
  (interactive)
  (when (eq major-mode 'c-mode)
    (let ((start-point (point))
          (start-line (line-number-at-pos))
          (original-content (buffer-string)))
      (condition-case err
          (progn
            (let ((formatted-content
                   (with-temp-buffer
                     (insert original-content)
                     (let ((exit-code (call-process-region (point-min) (point-max)
                                                          "clang-format" t t nil
                                                          "--style={BasedOnStyle: Google, ColumnLimit: 120, IndentWidth: 2}"
                                                          "--assume-filename=.c")))
                       (if (= exit-code 0)
                           (buffer-string)
                         (error "clang-format failed with exit code %d" exit-code))))))
              (erase-buffer)
              (insert formatted-content)
              (goto-line start-line)
              (message "Buffer formatted with clang-format")))
        (error
         (erase-buffer)
         (insert original-content)
         (goto-char start-point)
         (message "Formatting failed, buffer restored: %s" (error-message-string err)))))))

;; Format current file and save
(defun format-and-save ()
  "Format the current buffer and save it."
  (interactive)
  (format-buffer)
  (save-buffer)
  (message "File formatted and saved"))

;; Key bindings for C formatting (mode-specific to avoid conflicts)
(add-hook 'c-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c f") 'format-buffer)
            (local-set-key (kbd "C-c F") 'format-and-save)))

;; Auto-close compilation window on success, keep open on failure
(defun my-compilation-finish-function (buffer status)
  "Close compilation buffer if successful, keep open if failed."
  (let ((window (get-buffer-window buffer)))
    (cond
     ;; Success - close window after brief delay
     ((string-match "finished" status)
      (run-with-timer 1.0 nil
                      (lambda ()
                        (when (get-buffer-window buffer)
                          (delete-window (get-buffer-window buffer)))
                        (message "Build successful - compilation window closed"))))
     ;; Failure - keep window open and show message
     ((string-match "exited abnormally" status)
      (message "Build failed - check compilation buffer for errors"))
     ;; Other statuses - do nothing
     (t nil))))

(add-hook 'compilation-finish-functions 'my-compilation-finish-function)

;; Better compilation window behavior
(setq compilation-window-height 15)           ; Reasonable window height
(setq compilation-scroll-output 'first-error) ; Scroll to first error
#+END_SRC

** Go Language Settings
Configure Go development with gopls LSP and modern tooling.

#+BEGIN_SRC emacs-lisp
;; Go mode
(unless (package-installed-p 'go-mode)
  (package-install 'go-mode))

(require 'go-mode)

;; Configure gopls for Go files
(add-to-list 'eglot-server-programs '(go-mode . ("gopls")))

;; Automatically start Eglot for Go files
(add-hook 'go-mode-hook 'eglot-ensure)

;; Go-specific settings
(add-hook 'go-mode-hook
          (lambda ()
            (setq tab-width 4)                    ; Go uses tabs, 4-space width
            (setq indent-tabs-mode t)             ; Use actual tabs for Go
            (setq go-ts-mode-indent-offset 4)     ; Consistent indentation
            ;; Insert header for new Go files
            (insert-go-header)))

;; Go formatting with goimports (better than gofmt)
(defun go-format-buffer ()
  "Format Go buffer with goimports."
  (interactive)
  (when (eq major-mode 'go-mode)
    (let ((start-point (point))
          (start-line (line-number-at-pos))
          (original-content (buffer-string)))
      (condition-case err
          (progn
            (let ((formatted-content
                   (with-temp-buffer
                     (insert original-content)
                     (let ((exit-code (call-process-region (point-min) (point-max)
                                                          "goimports" t t nil)))
                       (if (= exit-code 0)
                           (buffer-string)
                         (error "goimports failed with exit code %d" exit-code))))))
              (erase-buffer)
              (insert formatted-content)
              (goto-line start-line)
              (message "Go buffer formatted with goimports")))
        (error
         (erase-buffer)
         (insert original-content)
         (goto-char start-point)
         (message "Go formatting failed, buffer restored: %s" (error-message-string err)))))))

;; Go format and save
(defun go-format-and-save ()
  "Format Go buffer and save it."
  (interactive)
  (go-format-buffer)
  (save-buffer))

;; Key bindings for Go formatting
(define-key go-mode-map (kbd "C-c f") 'go-format-buffer)    ; Format Go buffer
(define-key go-mode-map (kbd "C-c F") 'go-format-and-save)  ; Format and save
#+END_SRC

** Odin Language Settings
Configure Odin development with ols LSP and modern tooling.

#+BEGIN_SRC emacs-lisp
;; Download and install proper odin-mode from GitHub
(let ((odin-mode-dir (expand-file-name "odin-mode" user-emacs-directory))
      (odin-mode-file (expand-file-name "odin-mode/odin-mode.el" user-emacs-directory)))
  (unless (file-exists-p odin-mode-file)
    (message "Downloading odin-mode from GitHub...")
    (make-directory odin-mode-dir t)
    (url-copy-file "https://raw.githubusercontent.com/mattt-b/odin-mode/master/odin-mode.el"
                   odin-mode-file t))

  ;; Load the odin-mode
  (load-file odin-mode-file)
  (require 'odin-mode))

;; Configure ols (Odin Language Server) for Odin files
(add-to-list 'eglot-server-programs '(odin-mode . ("ols")))

;; Automatically start Eglot for Odin files
(add-hook 'odin-mode-hook 'eglot-ensure)

;; Odin-specific settings with AGGRESSIVE Unicode and font support
(add-hook 'odin-mode-hook
          (lambda ()
            (setq tab-width 4)                    ; Odin uses 4-space tabs
            (setq indent-tabs-mode t)             ; Use actual tabs for Odin
            (setq c-basic-offset 4)               ; 4-space indentation

            ;; Insert header for new Odin files first
            (insert-odin-header)

            ;; NUCLEAR FONT AND UNICODE ENFORCEMENT - runs after mode is set up
            (run-with-idle-timer 0.1 nil
              (lambda ()
                (with-current-buffer (current-buffer)
                  (when (eq major-mode 'odin-mode)
                    ;; Force UTF-8 encoding aggressively
                    (set-buffer-file-coding-system 'utf-8-unix)
                    (setq buffer-file-coding-system 'utf-8-unix)
                    (prefer-coding-system 'utf-8)

                    ;; FORCE JetBrains font on ALL Odin font-lock faces
                    (when (member "JetBrainsMono Nerd Font" (font-family-list))
                      ;; Override ALL odin font-lock faces
                      (dolist (face '(font-lock-keyword-face font-lock-type-face
                                      font-lock-function-name-face font-lock-variable-name-face
                                      font-lock-constant-face font-lock-builtin-face
                                      font-lock-string-face font-lock-comment-face
                                      font-lock-preprocessor-face font-lock-doc-face))
                        (when (facep face)
                          (set-face-attribute face nil :family "JetBrainsMono Nerd Font" :height 110)))

                      ;; Force buffer-specific font (nuclear option)
                      (setq buffer-face-mode-face '(:family "JetBrainsMono Nerd Font" :height 110))
                      (buffer-face-mode 1)

                      ;; Force fontset configuration for Unicode
                      (set-fontset-font t 'unicode "JetBrainsMono Nerd Font" nil 'prepend)
                      (set-fontset-font t 'unicode "Segoe UI Symbol" nil 'append)
                      (set-fontset-font t 'unicode "Segoe UI Emoji" nil 'append)

                      ;; Force font for specific Unicode ranges that might fail
                      (set-fontset-font t '(#x2190 . #x21FF) "JetBrainsMono Nerd Font" nil 'prepend) ; Arrows
                      (set-fontset-font t '(#x2200 . #x22FF) "JetBrainsMono Nerd Font" nil 'prepend) ; Math
                      (set-fontset-font t '(#x2500 . #x257F) "JetBrainsMono Nerd Font" nil 'prepend) ; Box drawing
                      (set-fontset-font t '(#x2600 . #x26FF) "Segoe UI Symbol" nil 'append)         ; Misc symbols

                      ;; Force redisplay
                      (redraw-display)
                      (font-lock-fontify-buffer)

                      (message "NUCLEAR Unicode and font enforcement applied to Odin mode"))))))))

;; Odin file header function
(defun insert-odin-header ()
  "Insert standard Odin file header for new files."
  (when (and (buffer-file-name)
             (= (point-min) (point-max))  ; Empty file
             (string-match-p "\\.odin$" (buffer-file-name)))
    (let ((filename (file-name-nondirectory (buffer-file-name)))
          (package-name (file-name-nondirectory (directory-file-name default-directory))))
      (insert (format "// Package %s\n" package-name))
      (insert (format "// File: %s\n" filename))
      (insert (format "// Author: Christer Söderlund <christer.soderlund@gmail.com>\n"))
      (insert (format "// Date: %s\n" (format-time-string "%Y-%m-%d")))
      (insert (format "// Copyright (c) %s Christer Söderlund\n\n" (format-time-string "%Y")))
      (insert (format "package %s\n\n" package-name))
      (insert "import \"core:fmt\"\n\n")
      (insert "main :: proc() {\n")
      (insert "    fmt.println(\"Hello, Odin!\")\n")
      (insert "}\n")
      (goto-char (point-min))
      (search-forward "Package ")
      (message "Odin header inserted - fill in package description"))))

;; Odin formatting with odinfmt
(defun odin-format-buffer ()
  "Format Odin buffer with odinfmt."
  (interactive)
  (when (eq major-mode 'odin-mode)
    (let ((start-point (point))
          (start-line (line-number-at-pos))
          (original-content (buffer-string)))
      (condition-case err
          (progn
            (let ((formatted-content
                   (with-temp-buffer
                     (insert original-content)
                     (let ((exit-code (call-process-region (point-min) (point-max)
                                                          "odinfmt" t t nil
                                                          "-stdin")))
                       (if (= exit-code 0)
                           (buffer-string)
                         (error "odinfmt failed with exit code %d" exit-code))))))
              (erase-buffer)
              (insert formatted-content)
              (goto-line start-line)
              (message "Odin buffer formatted with odinfmt")))
        (error
         (erase-buffer)
         (insert original-content)
         (goto-char start-point)
         (message "Odin formatting failed, buffer restored: %s" (error-message-string err)))))))

;; Odin format and save
(defun odin-format-and-save ()
  "Format Odin buffer and save it."
  (interactive)
  (odin-format-buffer)
  (save-buffer))

;; Key bindings for Odin formatting
(define-key odin-mode-map (kbd "C-c f") 'odin-format-buffer)    ; Format Odin buffer
(define-key odin-mode-map (kbd "C-c F") 'odin-format-and-save)  ; Format and save

;; Comprehensive Unicode diagnostic and fix for Odin mode
(defun diagnose-odin-unicode-simple ()
  "Diagnose and fix Unicode issues in Odin mode with detailed reporting."
  (interactive)
  (when (eq major-mode 'odin-mode)
    (let ((issues '())
          (fixes '()))

      ;; Check current encoding
      (let ((current-encoding buffer-file-coding-system))
        (message "Current encoding: %s" current-encoding)
        (unless (memq current-encoding '(utf-8 utf-8-unix utf-8-dos))
          (push "Non-UTF-8 encoding detected" issues)
          (set-buffer-file-coding-system 'utf-8-unix)
          (push "Forced UTF-8 encoding" fixes)))

      ;; Check current font
      (let ((current-font (face-attribute 'default :family)))
        (message "Current font: %s" current-font)
        (unless (string= current-font "JetBrainsMono Nerd Font")
          (push "Non-JetBrains font detected" issues)
          (when (member "JetBrainsMono Nerd Font" (font-family-list))
            (setq buffer-face-mode-face '(:family "JetBrainsMono Nerd Font" :height 110))
            (buffer-face-mode 1)
            (push "Forced JetBrains font" fixes))))

      ;; Check fontset configuration
      (let ((unicode-font (fontset-font t #x2192))) ; Right arrow
        (message "Unicode arrow font: %s" unicode-font)
        (unless (and unicode-font (string-match "JetBrains\\|Segoe" (symbol-name unicode-font)))
          (push "Unicode fontset not configured" issues)
          ;; Reconfigure fontset
          (set-fontset-font t 'unicode "JetBrainsMono Nerd Font" nil 'prepend)
          (set-fontset-font t 'unicode "Segoe UI Symbol" nil 'append)
          (set-fontset-font t 'unicode "Segoe UI Emoji" nil 'append)
          (push "Reconfigured Unicode fontset" fixes)))

      ;; Force font-lock refresh
      (font-lock-fontify-buffer)
      (redraw-display)
      (push "Refreshed display" fixes)

      ;; Report results
      (if issues
          (message "[FIX] Issues found: %s | Fixes applied: %s"
                   (string-join issues ", ") (string-join fixes ", "))
        (message "[OK] No Unicode issues detected in Odin mode"))

      ;; Insert test Unicode characters for verification
      (when (and (called-interactively-p 'interactive) (not buffer-read-only))
        (save-excursion
          (goto-char (point-max))
          (insert "\n// Unicode test: arrows and symbols\n")
          (message "Test Unicode characters inserted at end of buffer"))))))

;; Enhanced manual fix function
(defun fix-odin-unicode ()
  "Manually fix Unicode and font issues in current Odin buffer."
  (interactive)
  (diagnose-odin-unicode-simple))

;; Add keybinding for manual Unicode fix
(define-key odin-mode-map (kbd "C-c u") 'fix-odin-unicode)
#+END_SRC

* Build System Integration
** Dream Project Build & Run Commands
Quick build, run, and debug functions for the Dream project.

#+BEGIN_SRC emacs-lisp
;; Enhanced smart build command - detects ALL project types with debugging
(defun smart-build ()
  "Build project using appropriate build system based on project type with enhanced detection."
  (interactive)
  (let* ((project-root (or (condition-case nil (projectile-project-root) (error nil))
                          default-directory))
         (current-file (buffer-file-name))
         (current-mode major-mode)
         (cmake-file (expand-file-name "CMakeLists.txt" project-root))
         (go-mod-file (expand-file-name "go.mod" project-root))
         (go-files (directory-files project-root nil "\\.go$"))
         (odin-files (directory-files project-root nil "\\.odin$")))

    ;; Debug output
    (message "Smart Build Debug: mode=%s, root=%s, odin-files=%d, current-file=%s"
             current-mode project-root (length odin-files)
             (if current-file (file-name-nondirectory current-file) "none"))

    (cond
     ;; CMake project (like Dream)
     ((file-exists-p cmake-file)
      (let ((default-directory project-root))
        (compile "cmake --build build --config Release")))

     ;; Go project with go.mod
     ((file-exists-p go-mod-file)
      (let ((default-directory project-root))
        (compile "go build -v ./...")))

     ;; Go files without go.mod (single file)
     ((and go-files (eq major-mode 'go-mode))
      (let ((current-file (buffer-file-name)))
        (compile (format "go build -v %s" (file-name-nondirectory current-file)))))

     ;; Odin project - enhanced detection and library support
     ((or odin-files (eq major-mode 'odin-mode))
      (let ((default-directory project-root)
            (main-file (or (file-exists-p (expand-file-name "main.odin" project-root))
                          (file-exists-p (expand-file-name "app.odin" project-root))))
            (project-name (file-name-nondirectory (directory-file-name project-root))))
        (message "Building Odin project: %s (files: %d)" project-name (length odin-files))
        (cond
         ;; Multi-file project with main entry point
         ((and (> (length odin-files) 1) main-file)
          (compile (format "odin -o %s.exe main.odin" project-name)))
         ;; Multi-file project without clear main - use current file
         ((> (length odin-files) 1)
          (if current-file
              (compile (format "odin -o %s.exe %s"
                              (file-name-sans-extension (file-name-nondirectory current-file))
                              (file-name-nondirectory current-file)))
            (compile "odin -o main.exe main.odin")))
         ;; Single file - build directly
         ((and current-file (string-match "\\.odin$" current-file))
          (let ((basename (file-name-sans-extension (file-name-nondirectory current-file))))
            (compile (format "odin -o %s.exe %s"
                            basename (file-name-nondirectory current-file)))))
         ;; Fallback
         (t
          (compile "odin -o main.exe main.odin")))))

     ;; C file without CMake (single file compile)
     ((eq major-mode 'c-mode)
      (let ((current-file (buffer-file-name)))
        (compile (format "clang -std=c11 -o %s %s"
                        (file-name-sans-extension (file-name-nondirectory current-file))
                        (file-name-nondirectory current-file)))))

     ;; Default fallback
     (t
      (message "No recognized build system found in project")))))

;; Keep dream-specific build for explicit use
(defun dream-build ()
  "Build the dream project using CMake."
  (interactive)
  (let ((default-directory "G:/repos/dream/"))
    (compile "cmake --build build --config Release --target dream")))

;; Dream functions are referenced by keybindings but need to be defined
(defun dream-run ()
  "Run the dream project executable."
  (interactive)
  (let* ((project-root "G:/repos/dream/")
         (exe-path (expand-file-name "build/Release/dream.exe" project-root)))
    (if (file-exists-p exe-path)
        (let ((default-directory project-root))
          (async-shell-command exe-path "*Dream Output*"))
      (message "Dream executable not found. Build first with F5."))))

(defun dream-debug ()
  "Debug the dream project with RemedyBG."
  (interactive)
  (let* ((project-root "G:/repos/dream/")
         (exe-path (expand-file-name "build/Release/dream.exe" project-root))
         (remedybg-path "C:/remedybg.exe"))
    (if (file-exists-p exe-path)
        (if (file-exists-p remedybg-path)
            (async-shell-command (format "\"%s\" \"%s\"" remedybg-path exe-path))
          (message "RemedyBG not found at C:/remedybg.exe"))
      (message "Dream executable not found. Build first with F5."))))

;; Enhanced key bindings for build/run/debug workflow
(global-set-key [f3] 'smart-build)        ; F3 = Smart Build (detects project type)
(global-set-key [f5] 'dream-build)        ; F5 = Dream-specific build
(global-set-key [f6] 'dream-run)          ; F6 = Dream-specific run
(global-set-key [S-f6] 'dream-debug)      ; Shift+F6 = Dream-specific debug

;; Build system shortcuts
(global-set-key (kbd "C-c b b") 'smart-build)    ; Build
(global-set-key (kbd "C-c b d") 'dream-build)    ; Dream build
#+END_SRC

* Developer Tools
** Multiple Cursors and Additional Tools
Some additional development tools for productivity.

#+BEGIN_SRC emacs-lisp
;; Multiple cursors for efficient editing
(unless (package-installed-p 'multiple-cursors)
  (package-install 'multiple-cursors))

(require 'multiple-cursors)
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)

;; Company for better autocompletion
(unless (package-installed-p 'company)
  (package-install 'company))

(require 'company)
(add-hook 'after-init-hook 'global-company-mode)
(setq company-idle-delay 0.2)
(setq company-minimum-prefix-length 1)

;; Which-key for discoverable keybindings
(unless (package-installed-p 'which-key)
  (package-install 'which-key))

(require 'which-key)
(which-key-mode)

;; Magit for Git integration
(unless (package-installed-p 'magit)
  (package-install 'magit))

(global-set-key (kbd "C-x g") 'magit-status)

;; Quick copy entire buffer with Ctrl+Backspace
(defun copy-entire-buffer ()
  "Copy the entire buffer to clipboard without moving cursor or changing selection."
  (interactive)
  (let ((current-pos (point)))
    (save-excursion
      (kill-ring-save (point-min) (point-max)))
    (goto-char current-pos)
    (deactivate-mark)
    (message "Entire buffer copied to clipboard")))

(global-set-key (kbd "C-<backspace>") 'copy-entire-buffer)

;; Smart commenting
(defun my-comment-dwim ()
  "Smart comment/uncomment that works on lines or regions."
  (interactive)
  (cond
   ;; If region is active, comment/uncomment the region
   ((use-region-p)
    (comment-or-uncomment-region (region-beginning) (region-end)))
   ;; If line is already commented, uncomment it
   ((save-excursion
      (beginning-of-line)
      (looking-at "^[ \t]*//\\|^[ \t]*/\\*\\|^[ \t]*#"))
    (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
   ;; Otherwise, comment the current line
   (t
    (comment-or-uncomment-region (line-beginning-position) (line-end-position)))))

(global-set-key (kbd "C-/") 'my-comment-dwim)

;; Disable annoying confirmation prompts
(setq confirm-kill-emacs nil)
(setq confirm-kill-processes nil)
(setq kill-buffer-query-functions nil)
(setq large-file-warning-threshold nil)
(setq vc-follow-symlinks t)
(setq enable-recursive-minibuffers t)

;; Force kill Emacs without prompts
(defun my-force-kill-emacs ()
  "Force kill Emacs without any prompts about modified buffers or processes."
  (interactive)
  (let ((kill-buffer-query-functions nil)
        (confirm-kill-processes nil)
        (confirm-kill-emacs nil))
    ;; Kill all processes without asking
    (dolist (proc (process-list))
      (when (process-live-p proc)
        (delete-process proc)))
    ;; Mark all buffers as unmodified to avoid save prompts
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (set-buffer-modified-p nil)))
    ;; Now exit
    (kill-emacs)))

(global-set-key (kbd "C-x C-c") 'my-force-kill-emacs)

;; Better buffer navigation
(global-set-key (kbd "C-<tab>") 'next-buffer)
(global-set-key (kbd "C-S-<tab>") 'previous-buffer)

;; Window management
(global-set-key (kbd "C-x 2") 'split-window-below)
(global-set-key (kbd "C-x 3") 'split-window-right)
(global-set-key (kbd "C-x 0") 'delete-window)
(global-set-key (kbd "C-x 1") 'delete-other-windows)
#+END_SRC

* Usage Notes
** Key Bindings
*** Build/Run/Debug
- =F3= - Smart Build (detects project type)
- =F5= - Dream-specific build
- =F6= - Dream-specific run
- =Shift+F6= - Dream-specific debug

*** Dashboard & Navigation
- =C-c d= - Open interactive dashboard
- =C-c s c= - Create/switch to scratch buffer

*** File Finding & Navigation
- =C-x C-f= - Find files
- =C-x b= - Switch buffers
- =M-x= - Command palette

*** LSP Navigation
- =M-x eglot= - Start LSP server for current file (auto-starts)
- =M-.= - Go to definition (when LSP is active)
- =M-,= - Go back from definition

*** Git Integration
- =C-x g= - Magit status (staging, commits, push/pull)

*** Multiple Cursors
- =C-S-c C-S-c= - Edit multiple lines
- =C->= - Mark next like this
- =C-<= - Mark previous like this
- =C-c C-<= - Mark all like this

** LSP Features
When Eglot is active in a file, you get:
- Code completion
- Go to definition/declaration
- Find references
- Real-time diagnostics
- Hover documentation

## Build Integration
The build commands automatically detect your project type and use the appropriate build system.

* Auto Focus System
** Automatic Window Focusing
#+BEGIN_SRC emacs-lisp
;; Load auto-focus module for better UX
(let ((auto-focus-module (expand-file-name "modules/auto-focus.org" user-emacs-directory)))
  (when (file-exists-p auto-focus-module)
    (condition-case err
        (org-babel-load-file auto-focus-module)
      (error
       (message "Failed to load auto-focus module: %s" (error-message-string err))))))

;; Load Windows Unicode fix (critical for proper Unicode display)
(let ((unicode-module (expand-file-name "modules/windows-unicode-fix.org" user-emacs-directory)))
  (when (file-exists-p unicode-module)
    (condition-case err
        (org-babel-load-file unicode-module)
      (error
       (message "Failed to load Unicode fix module: %s" (error-message-string err))))))
#+END_SRC